<!DOCTYPE html>

<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Finanças Claras</title>
<script src="https://cdn.tailwindcss.com"></script>
<!-- Font Awesome para ícones "bonitinhos" -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" referrerpolicy="no-referrer" rel="stylesheet"/>
<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&amp;family=Inter:wght@300;400;500;600;700&amp;display=swap" rel="stylesheet"/>\
    <!-- Chart.js para gráficos -->
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
        /* Configuração de cores e fontes personalizadas do Tailwind */
        :root {
            --color-blue-light: hsl(210, 20%, 95%); /* #F0F5FA */
            --color-blue-primary: hsl(210, 70%, 50%); /* #3383FF */
            --color-cyan-accent: hsl(180, 60%, 40%); /* #33A6A6 */
            --color-text-dark: #334155; /* Cinza escuro ou azul-acinzentado */
            --color-green-positive: #22C55E; /* Verde para receitas */
            --color-red-negative: #EF4444; /* Vermelho para despesas */
            --color-option-icon-green: #308053; /* Verde dos ícones da página 'Mais Opções' na referência */
            --color-heading-green: #308053; /* Verde para o título "Transações" */
        }

        body {
            font-family: 'Inter', sans-serif; /* Corpo do texto */
            background-color: var(--color-blue-light);
            color: var(--color-text-dark);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        h1, h2, h3, h4, h5, h6 {
            font-family: 'Poppins', sans-serif; /* Títulos */
            color: var(--color-text-dark);
        }

        /* Estilo para a barra de navegação inferior (mobile) */
        .mobile-nav-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: white;
            box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            display: flex;
            justify-content: space-around;
            padding: 8px 0;
            border-top-left-radius: 1rem;
            border-top-right-radius: 1rem;
        }

        .mobile-nav-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 8px;
            color: var(--color-text-dark);
            text-decoration: none;
            font-size: 0.75rem; /* text-xs */
            font-weight: 500;
            border-radius: 0.5rem; /* rounded-md */
            transition: background-color 0.2s ease;
        }

        .mobile-nav-item.active {
            color: var(--color-blue-primary);
            background-color: hsla(210, 70%, 50%, 0.1); /* usando hsla para melhor compatibilidade com variáveis CSS */
        }
        .mobile-nav-item.active i { /* Alterado de svg para i para Font Awesome */
            color: var(--color-blue-primary);
        }
        .mobile-nav-item:hover {
            background-color: rgba(0,0,0,0.05);
        }

        /* Classes para simular abas/páginas */
        .page-section {
            display: none; /* Esconde todas as seções por padrão */
        }
        .page-section.active {
            display: block; /* Mostra a seção ativa */
        }

        /* Corrigir o problema do Tailwind com variáveis CSS e `rgba()` */
        @layer base {
            [data-page="dashboard"] .active .mobile-nav-item {
                --tw-text-opacity: 1;
                color: var(--color-blue-primary);
            }
        }

        /* Estilo para a bolinha de status na linha do tempo da transação */
        .transaction-bullet {
            position: absolute;
            left: -31.2px; /* Ajustado para puxar o texto para a esquerda */
            top: 50%;
            transform: translateY(-50%);
            width: 24px; /* Tamanho da bolinha (w-6) */
            height: 24px; /* Tamanho da bolinha (h-6) */
            border-radius: 50%;
            z-index: 10;
            box-sizing: border-box; /* Garante que o preenchimento não interfere com o contorno para bolinhas vazias */
            background-color: var(--color-blue-light); /* Mesma cor do body */
        }
        /* Para transações pagas, a cor preenche a bolinha */
        .transaction-bullet.paid {
            border: none;
        }

        .timeline-bullet-date {
            position: absolute; /* Garantir que seja posicionado */
            left: 1px; /* Ajustado para alinhar com o centro da linha do tempo */
            top: 0; /* Alinha com o topo do bloco de data */
            width: 26px;
            height: 26px;
            background-color: #CBD5E1; /* Cor de fundo para o ícone da data */
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10;
        }

        /* Estilo para o modal */
        .modal {
            display: none; /* Esconde o modal por padrão */
            position: fixed;
            z-index: 1001; /* Z-index alto para ficar acima de tudo */
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto; /* Permite scroll se o conteúdo for grande */
            background-color: rgba(0,0,0,0.4); /* Fundo escuro transparente */
            align-items: center;
            justify-content: center;
        }
        .modal.active {
            display: flex; /* Mostra o modal */
        }
        .modal-content {
            background-color: #fefefe;
            margin: auto;
            padding: 20px;
            border-radius: 0.75rem; /* rounded-lg */
            width: 90%;
            max-width: 500px; /* Largura máxima para o modal */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }
        .close-button {
            color: #aaa;
            position: absolute;
            top: 10px;
            right: 10px;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }
        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        /* Estilos para o modal de confirmação */
        .confirmation-modal-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .confirmation-modal-buttons button {
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: background-color 0.2s ease;
        }
        .confirmation-modal-buttons .confirm-delete {
            background-color: #EF4444; /* Tailwind red-500 */
            color: white;
        }
        .confirmation-modal-buttons .confirm-delete:hover {
            background-color: #DC2626; /* Tailwind red-600 */
        }
        .confirmation-modal-buttons .cancel-delete {
            background-color: #E5E7EB; /* Tailwind gray-200 */
            color: #374151; /* Tailwind gray-700 */
        }
        .confirmation-modal-buttons .cancel-delete:hover {
            background-color: #D1D5DB; /* Tailwind gray-300 */
        }

        /* Estilos para os botões de tipo na Etapa 1 do modal de transação */
        .step-1-type-button {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: white;
            border: 1px solid #E5E7EB; /* gray-200 */
            border-radius: 0.75rem; /* rounded-lg */
            padding: 1rem;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }

        .step-1-type-button:hover {
            border-color: var(--color-blue-primary);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .step-1-type-button.selected {
            border-color: var(--color-blue-primary);
            background-color: hsla(210, 70%, 50%, 0.1);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        .step-container {
            display: flex;
            flex-direction: column;
            height: 100%; /* Garante que o contêiner da etapa ocupe a altura total */
        }

        /* Estilo para a bolinha do slider (thumb) */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px; /* Tamanho da bolinha */
            height: 24px; /* Tamanho da bolinha */
            border-radius: 50%;
            background: var(--color-green-positive); /* Cor verde */
            cursor: grab;
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2); /* Sombra suave */
            margin-top: -8px; /* Ajuste para centralizar verticalmente */
        }

        input[type="range"]::-moz-range-thumb {
            width: 24px; /* Tamanho da bolinha */
            height: 24px; /* Tamanho da bolinha */
            border-radius: 50%;
            background: var(--color-green-positive); /* Cor verde */
            cursor: grab;
            box-shadow: 0 0 0 4px rgba(34, 197, 94, 0.2); /* Sombra suave */
        }

        input[type="range"]::-webkit-slider-runnable-track {
            width: 100%;
            height: 8px; /* Altura da barra */
            background: #e2e8f0; /* Cor da trilha */
            border-radius: 5px;
        }

        input[type="range"]::-moz-range-track {
            width: 100%;
            height: 8px; /* Altura da barra */
            background: #e2e8f0; /* Cor da trilha */
            border-radius: 5px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col"><section class="absolute inset-0 bg-gray-100 flex items-center justify-center p-4" id="login-screen">
<div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md">
<h2 class="text-3xl font-bold text-center text-gray-900 mb-6">Finanças Claras</h2>
<p class="text-center text-gray-600 mb-8">Faça login para acessar suas finanças.</p>
<form class="space-y-6" id="login-form">
<div>
<label class="block text-sm font-medium text-gray-700" for="login-email">Email</label>
<input class="mt-1 block w-full p-3 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500" id="login-email" placeholder="seuemail@exemplo.com" required="" type="email"/>
</div>
<div>
<label class="block text-sm font-medium text-gray-700" for="login-password">Senha</label>
<input class="mt-1 block w-full p-3 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)]" id="login-password" placeholder="********" required="" type="password"/>
</div>
<button class="w-full py-3 px-4 border border-transparent rounded-md shadow-sm text-lg font-medium text-white bg-[var(--color-blue-primary)] hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300" type="submit">
                    Entrar
                </button>
<div class="text-red-500 text-sm text-center mt-4 hidden" id="login-error-message"></div>
</form>
</div>
</section>
<!-- Conteúdo Principal da Aplicação -->
<div class="flex-grow flex flex-col hidden" id="app-content">
<!-- Cabeçalho Principal (Desktop) -->
<header class="bg-white p-4 shadow-sm hidden md:block border-b border-gray-200">
<div class="container mx-auto flex justify-between items-center">
<h1 class="text-3xl font-bold text-gray-900">Finanças Claras</h1>
<nav class="flex items-center space-x-6">
<ul class="flex space-x-6">
<li><a class="nav-link text-lg font-medium hover:text-blue-primary transition duration-200 rounded-md py-2 px-3" data-page="dashboard" href="#">Visão Geral</a></li>
<li><a class="nav-link text-lg font-medium hover:text-blue-primary transition duration-200 rounded-md py-2 px-3" data-page="transactions" href="#">Transações</a></li>
<li><a class="nav-link text-lg font-medium hover:text-blue-primary transition duration-200 rounded-md py-2 px-3" data-page="chat" href="#">Assistente IA</a></li>
<li><a class="nav-link text-lg font-medium hover:text-blue-primary transition duration-200 rounded-md py-2 px-3" data-page="more-options" href="#">Mais Opções</a></li>
</ul>
<button class="px-4 py-2 bg-red-500 text-white font-medium rounded-md hover:bg-red-600 transition duration-300" id="logout-button-desktop">Sair</button>
</nav>
</div>
</header>
<main class="container mx-auto p-4 flex-grow pb-32 md:pb-8"> <!-- Ajustado: pb-24 para pb-32 em mobile -->
<!-- Visão Geral (Dashboard) -->
<section class="page-section active" id="dashboard">
<h2 class="text-3xl font-bold mb-2 text-[var(--color-heading-green)]">Visão Geral</h2>
<p class="text-gray-600 text-lg mb-6">Seu resumo financeiro rápido.</p>
<!-- Cards de Resumo da Visão Geral -->
<div class="space-y-4 mb-8">
<!-- Card Saldo Atual -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Saldo Atual</p>
<p class="font-bold text-3xl text-[var(--color-blue-primary)]" id="dashboard-current-balance">R$ 0,00</p>
<p class="text-sm text-gray-500">Seu dinheiro disponível.</p>
</div>
<!-- Ícone de carteira -->
<i class="fa-solid fa-wallet text-3xl"></i>
</div>
<!-- Card Receitas do Mês -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Receitas do Mês</p>
<p class="font-bold text-3xl text-[var(--color-green-positive)]" id="dashboard-monthly-income">R$ 0,00</p>
<p class="text-sm text-gray-500">Total de entradas no mês.</p>
</div>
<!-- Ícone de seta para cima para receitas -->
<i class="fa-solid fa-arrow-trend-up text-3xl"></i>
</div>
<!-- Card Despesas do Mês -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Despesas do Mês</p>
<p class="font-bold text-3xl text-[var(--color-red-negative)]" id="dashboard-monthly-expenses">R$ 0,00</p>
<p class="text-sm text-gray-500">Total de saídas no mês.</p>
</div>
<!-- Ícone de seta para baixo para despesas -->
<i class="fa-solid fa-arrow-trend-down text-3xl"></i>
</div>
</div>
<!-- Novo botão para Insights Financeiros -->
<button class="w-full sm:w-auto px-6 py-3 bg-yellow-500 text-white font-medium rounded-lg hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-yellow-500 transition duration-300 shadow-md mb-8" id="generate-insights-button">
                    ✨ Gerar Insights Financeiros
                </button>
<!-- EM #dashboard, SUBSTITUA O PLACEHOLDER DE GRÁFICO POR ISTO -->
<div class="bg-white p-6 rounded-lg shadow-md">
<h3 class="text-xl font-semibold mb-4">Despesas do Mês por Categoria</h3>
<div class="h-64 md:h-80">
<canvas id="expense-chart"></canvas>
</div>
</div>
</section>
<!-- Transações -->
<section class="page-section" id="transactions">
<h2 class="text-3xl font-bold mb-2 text-[var(--color-heading-green)]">Transações</h2>
<p class="text-gray-600 text-lg mb-6">Suas movimentações e resumo financeiro.</p>
<!-- Cards de Resumo de Transações -->
<div class="space-y-4 mb-8">
<!-- Card Saldo Atual (agora calculado dinamicamente) -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Saldo Atual</p>
<p class="font-bold text-3xl text-[var(--color-blue-primary)]" id="transactions-current-balance">R$ 0,00</p>
<p class="text-sm text-gray-500">Receitas - Despesas</p>
</div>
<!-- Ícone de carteira -->
<i class="fa-solid fa-wallet text-3xl"></i>
</div>
<!-- Card Total de Despesas (agora calculado dinamicamente) -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Total de Despesas</p>
<p class="font-bold text-3xl text-[var(--color-red-negative)]" id="transactions-total-expenses">R$ 0,00</p>
<p class="text-sm text-gray-500">Soma de todas as despesas</p>
</div>
<!-- Ícone de seta para baixo ou similar para despesas -->
<i class="fa-solid fa-arrow-trend-down text-3xl"></i>
</div>
<!-- Card Total Guardado (Caixinhas) - Agora ligado às caixinhas reais -->
<div class="bg-white p-5 rounded-lg shadow-md flex items-center justify-between">
<div>
<p class="text-base text-gray-600">Total Guardado (Caixinhas)</p>
<p class="font-bold text-3xl text-[var(--color-blue-primary)]" id="transactions-total-caixinhas-saved">R$ 0,00</p>
<p class="text-sm text-gray-500">Soma do valor atual das suas caixinhas</p>
</div>
<!-- Ícone de cofrinho -->
<i class="fa-solid fa-piggy-bank text-3xl"></i>
</div>
</div>
<div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 mb-8">
<button class="w-full sm:w-auto px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300 shadow-md" id="add-new-transaction-button">
                        Adicionar Transação
                    </button>
</div>
<!-- Lista de Transações - Agrupadas por Data (agora dinâmicas) -->
<div class="relative" id="transactions-list-container">
<!-- Linha do tempo vertical sutil -->
<div class="absolute left-3 top-0 bottom-0 w-0.5 bg-gray-200"></div>
<!-- Transações serão renderizadas aqui pelo JavaScript -->
<p class="text-center text-gray-500 py-4" id="no-transactions-message">Nenhuma transação cadastrada ainda.</p>
</div>
</section>
<!-- Chat com IA (Assistente) -->
<section class="page-section" id="chat">
<h2 class="text-3xl font-bold mb-6 text-gray-900">Assistente IA</h2>
<div class="bg-white p-6 rounded-lg shadow-md flex flex-col flex-grow min-h-[300px] relative">
<!-- Área de Mensagens -->
<!-- Adicionado 'pb-20' para que o conteúdo não seja escondido pela caixa de entrada fixa -->
<div class="flex-grow overflow-y-auto p-4 space-y-4 pb-20" id="chat-messages">
<!-- Mensagem da IA de introdução -->
<div class="flex justify-start">
<div class="bg-gray-100 text-gray-800 p-3 rounded-xl rounded-bl-none max-w-xs md:max-w-md shadow-sm">
                                Olá! Sou seu assistente financeiro. Por favor, insira sua chave da API Gemini em "Mais Opções" para que eu possa funcionar.
                            </div>
</div>
</div>
<!-- Indicador de Carregamento -->
<div class="text-center text-gray-500 py-2 hidden" id="chat-loading-indicator">
<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div>
                        Pensando...
                    </div>
<!-- Campo de Input de Texto e Botões (Fixo na parte inferior do contêiner do chat) -->
<div class="absolute bottom-0 left-0 right-0 p-4 bg-white border-t border-gray-200 flex items-center">
<button class="bg-gray-200 text-gray-600 p-3 rounded-full shadow-md hover:bg-gray-300 transition duration-300 mr-2" id="refresh-chat-data-button">
<i class="fa-solid fa-arrows-rotate text-lg"></i> <!-- Ícone de Atualizar -->
</button>
<!-- NOVO: Botão Limpar Chat -->
<button class="bg-gray-200 text-gray-600 p-3 rounded-full shadow-md hover:bg-gray-300 transition duration-300 mr-2" id="clear-chat-button">
<i class="fa-solid fa-trash-can text-lg"></i> <!-- Ícone de Limpar -->
</button>
<input class="flex-grow p-3 border border-gray-300 rounded-l-lg focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" disabled="" id="chat-input" placeholder="Assistente não configurado..." type="text"/>
<button class="px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-r-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300" disabled="" id="chat-send-button">
<!-- Ícone de Enviar -->
<i class="fa-solid fa-paper-plane"></i>
</button>
</div>
</div>
</section>
<!-- Mais Opções -->
<section class="page-section" id="more-options">
<h2 class="text-3xl font-bold mb-2 text-gray-900">Mais Opções</h2>
<p class="text-gray-600 text-lg mb-6">Explore funcionalidades e configurações adicionais.</p>
<div class="space-y-4">
<!-- Card/Link para Gerenciamento de API Gemini -->
<a class="flex items-center bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition duration-200" data-page="api-management" href="#">
<i class="fa-solid fa-key text-2xl text-[var(--color-option-icon-green)] mr-4"></i>
<div class="flex-grow">
<p class="font-semibold text-lg text-gray-800">Chave de API Gemini</p>
<p class="text-sm text-gray-600">Gerencie sua chave de acesso para o Assistente IA.</p>
</div>
<i class="fa-solid fa-chevron-right text-xl text-gray-400"></i>
</a>
<!-- Card/Link para Categorias e Caixinhas -->
<a class="flex items-center bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition duration-200" data-page="categories-management" href="#">
<i class="fa-solid fa-tags text-2xl text-[var(--color-option-icon-green)] mr-4"></i>
<div class="flex-grow">
<p class="font-semibold text-lg text-gray-800">Categorias e Caixinhas</p>
<p class="text-sm text-gray-600">Gerencie receitas, despesas e metas de poupança.</p>
</div>
<i class="fa-solid fa-chevron-right text-xl text-gray-400"></i>
</a>
<!-- Card/Link para Orçamento -->
<a class="flex items-center bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition duration-200" data-page="budget-management" href="#">
<i class="fa-solid fa-wallet text-2xl text-[var(--color-option-icon-green)] mr-4"></i>
<div class="flex-grow">
<p class="font-semibold text-lg text-gray-800">Orçamento</p>
<p class="text-sm text-gray-600">Defina e acompanhe seu orçamento mensal.</p>
</div>
<i class="fa-solid fa-chevron-right text-xl text-gray-400"></i>
</a>
<!-- Card/Link para Configurar IA (ATUALIZADO) -->
<a class="flex items-center bg-white p-4 rounded-lg shadow-md hover:shadow-lg transition duration-200" data-page="ai-config" href="#">
<i class="fa-solid fa-brain text-2xl text-[var(--color-option-icon-green)] mr-4"></i>
<div class="flex-grow">
<p class="font-semibold text-lg text-gray-800">Configurar IA</p>
<p class="text-sm text-gray-600">Personalize a persona e personalidade do assistente financeiro.</p>
</div>
<i class="fa-solid fa-chevron-right text-xl text-gray-400"></i>
</a>
<!-- Botão de Sair (Mobile) -->
<button class="w-full px-6 py-3 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500 transition duration-300 shadow-md flex items-center justify-center" id="logout-button-mobile">
<i class="fa-solid fa-right-from-bracket mr-2"></i> Sair
                    </button>
</div>
</section>
<!-- Seção de Gerenciamento de Categorias (Atualizada) -->
<section class="page-section" id="categories-management">
<h2 class="text-3xl font-bold mb-2 text-gray-900">Categorias e Caixinhas</h2>
<p class="text-gray-600 text-lg mb-6">Gerencie suas categorias de transações e metas de poupança.</p>
<div class="mb-6">
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="category-search-input" placeholder="Buscar categoria..." type="text"/>
</div>
<button class="w-full md:w-auto px-6 py-3 bg-green-600 text-white font-medium rounded-lg hover:bg-green-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-green-600 transition duration-300 shadow-md flex items-center justify-center mb-8" id="add-new-category-button">
<i class="fa-solid fa-plus mr-2"></i>
                    Nova Categoria ou Caixinha
                </button>
<div class="space-y-4" id="category-list-container">
<!-- Categorias e Caixinhas serão renderizadas aqui pelo JavaScript -->
</div>
</section>
<!-- Seção de Orçamento -->
<section class="page-section" id="budget-management">
<h2 class="text-3xl font-bold mb-6 text-gray-900">Meu Orçamento</h2>
<p class="text-gray-600 text-lg mb-6">Gerencie seus orçamentos mensais por categoria para controlar seus gastos.</p>
<div class="flex flex-col sm:flex-row space-y-2 sm:space-y-0 sm:space-x-4 mb-8">
<button class="w-full sm:w-auto px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300 shadow-md" id="configure-budget-button">
                        Configurar Orçamento Mensal
                    </button>
<button class="w-full sm:w-auto px-6 py-3 bg-indigo-500 text-white font-medium rounded-lg hover:bg-indigo-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition duration-300 shadow-md flex items-center justify-center" id="optimize-budget-button">
<i class="fa-solid fa-lightbulb mr-2"></i> Otimizar Orçamento com IA
                    </button>
</div>
<div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6" id="budget-list-container">
<!-- Orçamentos serão renderizados aqui pelo JavaScript -->
<p class="text-center text-gray-500 py-4 col-span-full" id="no-budgets-message">Nenhum orçamento configurado para este mês.</p>
</div>
</section>
<!-- Seção de Configuração da IA (NOVA ESTRUTURA) -->
<section class="page-section" id="ai-config">
<h2 class="text-3xl font-bold mb-2 text-gray-900">Configurar Assistente IA</h2>
<p class="text-gray-600 text-lg mb-6">Ajuste a persona e personalidade do seu assistente financeiro.</p>
<div class="bg-white p-6 rounded-lg shadow-md">
<div class="space-y-8">
<!-- Campo Personagem -->
<div class="space-y-2">
<label class="block text-lg font-semibold text-gray-800" for="ai-persona">
                                Personagem (Quem é a IA)
                            </label>
<textarea class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-[var(--color-blue-primary)] focus:border-[var(--color-blue-primary)]" id="ai-persona" placeholder="Descreva o papel principal da IA. Ex: Você é um coach financeiro durão..." rows="4"></textarea>
<p class="text-xs text-gray-500">
                                Esta é a diretriz principal que define o papel e o comportamento da IA.
                            </p>
</div>
<!-- Campo Personalidade (NOVO) -->
<div class="space-y-2">
<label class="block text-lg font-semibold text-gray-800" for="ai-personality">
                                Personalidade (Como a IA se comporta)
                            </label>
<textarea class="w-full p-3 border border-gray-300 rounded-md shadow-sm focus:ring-2 focus:ring-[var(--color-blue-primary)] focus:border-[var(--color-blue-primary)]" id="ai-personality" placeholder="Descreva o tone, o estilo de fala, o nível de formalidade e a profundidade das respostas. Ex: A IA é sempre encorajadora, usa linguagem simples e respostas concisas." rows="4"></textarea>
<p class="text-xs text-gray-500">
                                Descreva o tom, o estilo de fala e a profundidade das respostas da IA.
                            </p>
</div>
<!-- Mensagem de status de salvamento -->
<div class="mt-4 text-sm font-medium text-green-600 hidden" id="ai-config-status-message">
                            Configurações salvas!
                        </div>
<!-- NOVO: Botão Salvar Configurações -->
<div class="flex justify-end mt-6">
<button class="px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300 shadow-md" id="save-ai-config-button">
                                Salvar Configurações
                            </button>
</div>
</div>
</div>
</section>
</main>
<!-- Barra de Navegação Inferior (Mobile) -->
<footer class="mobile-nav-bar md:hidden">
<a class="mobile-nav-item active" data-page="dashboard" href="#">
<i class="fa-solid fa-table-columns text-xl"></i>
<span>Visão Geral</span>
</a>
<a class="mobile-nav-item" data-page="transactions" href="#">
<i class="fa-solid fa-list-check text-xl"></i>
<span>Transações</span>
</a>
<a class="mobile-nav-item" data-page="chat" href="#">
<!-- Ícone do Assistente IA (Bot) -->
<i class="fa-solid fa-robot text-xl"></i>
<span>Assistente</span>
</a>
<a class="mobile-nav-item" data-page="more-options" href="#">
<i class="fa-solid fa-ellipsis text-xl"></i>
<span>Mais</span>
</a>
</footer>
</div>
<!-- Modal para Adicionar/Editar Categoria (ATUALIZADO) -->
<div class="modal" id="category-modal">
<div class="modal-content">
<span class="close-button" id="close-category-modal">×</span>
<h3 class="text-2xl font-bold mb-4 text-gray-900" id="category-modal-title">Adicionar Nova Categoria</h3>
<form id="category-form">
<input id="category-id" type="hidden"/>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="category-name">Nome da Categoria</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="category-name" required="" type="text"/>
</div>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-2">Tipo</label>
<div class="flex space-x-4">
<label class="inline-flex items-center">
<input checked="" class="form-radio text-red-500" name="category-type" type="radio" value="expense"/>
<span class="ml-2 text-gray-700">Despesa</span>
</label>
<label class="inline-flex items-center">
<input class="form-radio text-green-500" name="category-type" type="radio" value="income"/>
<span class="ml-2 text-gray-700">Receita</span>
</label>
<label class="inline-flex items-center">
<input class="form-radio text-blue-500" name="category-type" type="radio" value="caixinha"/>
<span class="ml-2 text-gray-700">Caixinha</span>
</label>
</div>
</div>
<!-- ADICIONADO: Campo Valor Alvo para Caixinhas -->
<div class="mb-4 hidden" id="target-amount-field">
<label class="block text-sm font-medium text-gray-700 mb-1" for="category-target-amount">Valor Alvo (R$)</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="category-target-amount" inputmode="numeric" type="text"/>
</div>
<div class="mb-4" id="priority-field">
<label class="block text-sm font-medium text-gray-700 mb-2">Prioridade</label>
<div class="flex space-x-4">
<label class="inline-flex items-center">
<input checked="" class="form-radio text-green-500" name="category-priority" type="radio" value="essential"/>
<span class="ml-2 text-gray-700">Essencial</span>
</label>
<label class="inline-flex items-center">
<input class="form-radio text-red-500" name="category-priority" type="radio" value="non-essential"/>
<span class="ml-2 text-gray-700">Não Essencial</span>
</label>
</div>
</div>
<div class="flex justify-end space-x-4">
<button class="px-6 py-3 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300 shadow-md" id="cancel-category-button" type="button">
                        Cancelar
                    </button>
<button class="px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-[var(--color-blue-primary)] transition duration-300 shadow-md" type="submit">
                        Salvar Categoria
                    </button>
</div>
<div class="mt-4 text-sm font-medium hidden" id="category-save-status-message"></div>
</form>
</div>
</div>
<!-- Modal para Adicionar/Editar Transação (FLUXO MULTI-ETAPAS) -->
<div class="modal" id="transaction-modal">
<div class="modal-content">
<!-- O botão de fechar continua o mesmo -->
<span class="close-button" id="close-transaction-modal">×</span>
<form class="flex flex-col h-full" id="transaction-form">
<input id="transaction-id" type="hidden"/>
<!-- ETAPA 1: TIPO DE MOVIMENTAÇÃO -->
<div class="step-container" id="transaction-step-1">
<h3 class="text-2xl font-bold mb-2 text-gray-900">Qual o tipo de movimentação?</h3>
<p class="text-gray-600 mb-6">Selecione uma das opções para começar.</p>
<div class="grid grid-cols-2 gap-4 py-4 flex-1">
<button class="step-1-type-button h-full text-base flex-col gap-2 p-4 border rounded-lg hover:bg-gray-100 transition" data-type="income" type="button">
<i class="fa-solid fa-arrow-up text-green-500 text-2xl mb-2"></i>
<span class="font-semibold">Receita</span>
</button>
<button class="step-1-type-button h-full text-base flex-col gap-2 p-4 border rounded-lg hover:bg-gray-100 transition" data-type="expense" type="button">
<i class="fa-solid fa-arrow-down text-red-500 text-2xl mb-2"></i>
<span class="font-semibold">Despesa</span>
</button>
<button class="step-1-type-button h-full text-base flex-col gap-2 p-4 border rounded-lg hover:bg-gray-100 transition" data-type="deposit" type="button">
<i class="fa-solid fa-piggy-bank text-blue-500 text-2xl mb-2"></i>
<span class="font-semibold">Guardar</span>
</button>
<button class="step-1-type-button h-full text-base flex-col gap-2 p-4 border rounded-lg hover:bg-gray-100 transition" data-type="withdraw" type="button">
<i class="fa-solid fa-wallet text-indigo-500 text-2xl mb-2"></i>
<span class="font-semibold">Resgatar</span>
</button>
</div>
<div class="flex justify-end mt-4">
<button class="px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" id="cancel-transaction-button-step1" type="button">Cancelar</button>
</div>
</div>
<!-- ETAPA 2: VALOR E CATEGORIA -->
<div class="step-container hidden" id="transaction-step-2">
<h3 class="text-2xl font-bold mb-2 text-gray-900" id="step-2-title">Nova Despesa</h3>
<p class="text-gray-600 mb-6">Informe o valor e a categoria desta movimentação.</p>
<div class="space-y-6 py-4">
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="transaction-amount">Valor (R$)</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="transaction-amount" inputmode="numeric" required="" type="text"/>
</div>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="transaction-category">Categoria</label>
<select class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="transaction-category" required="">
<!-- Options will be populated by JS -->
</select>
</div>
</div>
<div class="flex justify-between mt-4">
<button class="step-back-button px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" type="button">Voltar</button>
<button class="step-next-button px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600" type="button">Continuar</button>
</div>
</div>
<!-- ETAPA 3: DETALHES ADICIONAIS -->
<div class="step-container hidden" id="transaction-step-3">
<h3 class="text-2xl font-bold mb-2 text-gray-900">Detalhes Adicionais</h3>
<p class="text-gray-600 mb-6">Adicione uma descrição e a data da transação.</p>
<div class="space-y-6 py-4">
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="transaction-description">Descrição (Opcional)</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="transaction-description" type="text"/>
</div>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="transaction-date">Data</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="transaction-date" required="" type="date"/>
</div>
</div>
<div class="flex justify-between mt-4">
<button class="step-back-button px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" type="button">Voltar</button>
<button class="step-next-button px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600" type="button">Continuar</button>
</div>
</div>
<!-- ETAPA 4: STATUS E RECORRÊNCIA -->
<div class="step-container hidden" id="transaction-step-4">
<h3 class="text-2xl font-bold mb-2 text-gray-900">Status e Finalização</h3>
<p class="text-gray-600 mb-6">Finalize os detalhes da sua transação.</p>
<div class="space-y-6 py-4">
<!-- SUBSTITUA O <select> DE STATUS POR ESTE BLOCO -->
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-2">Status</label>
<div class="flex space-x-2" id="transaction-status-options">
<!-- Opções serão geradas dinamicamente via JS -->
</div>
</div>
<!-- Futuramente, pode-se adicionar a lógica de recorrência aqui -->
</div>
<div class="flex justify-between mt-4">
<button class="step-back-button px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" type="button">Voltar</button>
<button class="px-6 py-3 bg-green-600 text-white font-medium rounded-lg hover:bg-green-700" type="submit">Salvar Transação</button>
</div>
</div>
<!-- Radios ocultos para guardar o estado do tipo -->
<div class="hidden">
<input name="transaction-type" type="radio" value="income"/>
<input name="transaction-type" type="radio" value="expense"/>
<input name="transaction-type" type="radio" value="deposit"/>
<input name="transaction-type" type="radio" value="withdraw"/>
</div>
</form>
</div>
</div>
<!-- Modal de Confirmação Genérico -->
<div class="modal" id="confirmation-modal">
<div class="modal-content">
<h3 class="text-2xl font-bold mb-4 text-gray-900" id="confirmation-modal-title"></h3>
<p class="text-gray-700 mb-6" id="confirmation-modal-message"></p>
<div class="confirmation-modal-buttons">
<button class="cancel-delete" id="cancel-confirmation-button" type="button">Cancelar</button>
<button class="confirm-delete" id="confirm-action-button" type="button">Confirmar</button>
</div>
</div>
</div>
<!-- Modal para Insights Financeiros -->
<div class="modal" id="insights-modal">
<div class="modal-content">
<span class="close-button" id="close-insights-modal">×</span>
<h3 class="text-2xl font-bold mb-4 text-gray-900">Insights Financeiros</h3>
<div class="min-h-[100px] flex flex-col justify-center items-center" id="insights-content">
<div class="text-center text-gray-500 py-2" id="insights-loading-indicator">
<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div>
                    Gerando insights...
                </div>
<p class="text-gray-700 text-center" id="insights-text"></p>
</div>
<div class="flex justify-end mt-4">
<button class="px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" id="close-insights-button" type="button">Fechar</button>
</div>
</div>
</div>
<!-- Modal para Otimização de Orçamento com IA -->
<div class="modal" id="budget-optimization-modal">
<div class="modal-content">
<span class="close-button" id="close-budget-optimization-modal">×</span>
<h3 class="text-2xl font-bold mb-4 text-gray-900">Otimização de Orçamento com IA</h3>
<div class="min-h-[100px] flex flex-col justify-center items-center" id="budget-optimization-content">
<div class="text-center text-gray-500 py-2" id="budget-optimization-loading-indicator">
<div class="animate-spin rounded-full h-8 w-8 border-b-2 border-gray-900 mx-auto"></div>
                    Analisando orçamento...
                </div>
<p class="text-gray-700 text-center" id="budget-optimization-text"></p>
</div>
<div class="flex justify-end mt-4">
<button class="px-6 py-3 bg-gray-200 text-gray-800 font-medium rounded-lg hover:bg-gray-300" id="close-budget-optimization-button" type="button">Fechar</button>
</div>
</div>
</div>
<!-- Modal para Gerenciamento de Chave de API Gemini (ATUALIZADO PARA 5 CAMPOS) -->
<div class="modal" id="api-keys-modal">
<div class="modal-content">
<span class="close-button" id="close-api-keys-modal">×</span>
<h3 class="text-2xl font-bold mb-4 text-gray-900">Gerenciar Chaves de API Gemini</h3>
<p class="text-gray-600 mb-6">Insira até 5 chaves de API. A aplicação tentará usar a primeira chave válida disponível.</p>
<div class="space-y-4 mb-4">
<div>
<label class="block text-sm font-medium text-gray-700 mb-1" for="modal-api-key-1">Chave de API 1</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="modal-api-key-1" placeholder="Cole sua chave de API aqui..." type="text"/>
</div>
<div>
<label class="block text-sm font-medium text-gray-700 mb-1" for="modal-api-key-2">Chave de API 2</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="modal-api-key-2" placeholder="Cole sua chave de API aqui..." type="text"/>
</div>
<div>
<label class="block text-sm font-medium text-gray-700 mb-1" for="modal-api-key-3">Chave de API 3</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="modal-api-key-3" placeholder="Cole sua chave de API aqui..." type="text"/>
</div>
<div>
<label class="block text-sm font-medium text-gray-700 mb-1" for="modal-api-key-4">Chave de API 4</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="modal-api-key-4" placeholder="Cole sua chave de API aqui..." type="text"/>
</div>
<div>
<label class="block text-sm font-medium text-gray-700 mb-1" for="modal-api-key-5">Chave de API 5</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="modal-api-key-5" placeholder="Cole sua chave de API aqui..." type="text"/>
</div>
</div>
<div class="p-3 rounded-md border text-sm hidden" id="api-modal-status-message">
<p id="api-modal-message-text"></p>
</div>
<div class="flex justify-end mt-4 space-x-4">
<button class="px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600" id="save-api-keys-modal-button" type="button">Salvar Chaves</button>
</div>
</div>
</div>
<!-- Modal para Adicionar/Editar Orçamento -->
<div class="modal" id="budget-modal">
<div class="modal-content">
<span class="close-button" id="close-budget-modal">×</span>
<h3 class="text-2xl font-bold mb-4 text-gray-900" id="budget-modal-title">Novo Orçamento</h3>
<p class="text-gray-600 mb-6">Defina um limite de gastos para uma categoria de despesa neste mês.</p>
<form id="budget-form">
<input id="budget-id" type="hidden"/>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="budget-category">Categoria de Despesa</label>
<select class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="budget-category" required="">
<!-- Opções de categorias de despesa serão populadas via JS -->
</select>
</div>
<div class="mb-4">
<label class="block text-sm font-medium text-gray-700 mb-1" for="budget-amount">Valor do Orçamento (R$)</label>
<input class="w-full p-3 border border-gray-300 rounded-md focus:outline-none focus:ring-2 focus:ring-[var(--color-blue-primary)]" id="budget-amount" inputmode="numeric" placeholder="0,00" required="" type="text"/>
</div>
<div class="flex justify-end space-x-4 mt-6">
<button class="px-6 py-3 bg-gray-300 text-gray-800 font-medium rounded-lg hover:bg-gray-400" id="cancel-budget-button" type="button">Cancelar</button>
<button class="px-6 py-3 bg-[var(--color-blue-primary)] text-white font-medium rounded-lg hover:bg-blue-600" type="submit">Salvar Orçamento</button>
</div>
</form>
</div>
</div>
<script type="module">
        // Importa os módulos necessários do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signOut, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, onSnapshot, addDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variáveis globais do ambiente Canvas (preenchidas em tempo de execução)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // Firebase Config agora usa a variável global __firebase_config
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Instâncias do Firebase
        let app;
        let db;
        let auth;
        let userId = null; 
        let isAuthReady = false; 

        // Arrays para armazenar os dados do usuário
        let categories = []; 
        let transactions = [];
        let budgets = []; 

        // Configurações da IA (ATUALIZADO)
        let aiConfig = {
            persona: "Você é um educador financeiro especialista...", 
            personality: "Sua personalidade é equilibrada e você responde de forma clara e objetiva." // Novo campo
        };

        // Múltiplas chaves de API Gemini (ARRAY)
        let geminiApiKeys = []; 
        let currentGeminiApiKeyIndex = 0; // Índice da chave de API atualmente em uso
        let chatHistory = []; 
        let isSendingMessage = false;
        let isGeminiApiReady = false; 

        // Flag e armazenamento para dados financeiros para a IA
        let hasConsultedFinancialData = false;
        let lastFinancialDataString = ''; 

        // NOVAS PALETAS DE CORES PARA ATRIBUIÇÃO AUTOMÁTICA
        const INCOME_COLORS = ['#2ecc71', '#1abc9c', '#1dd1a1', '#55efc4', '#00b894', '#00d084', '#00e676', '#00ff6a'];
        const ESSENTIAL_COLORS = ['#3498db', '#2980b9', '#8e44ad', '#34495e', '#6c5ce7', '#0984e3', '#a29bfe', '#636e72'];
        const NON_ESSENTIAL_COLORS = ['#e74c3c', '#e67e22', '#f1c40f', '#ff7675', '#d63031', '#fdcb6e', '#fab1a0', '#ffbe76'];
        const CAIXINHA_COLORS = ['#a29bfe', '#74b9ff', '#81ecec', '#ffeaa7', '#00cec9', '#6c5ce7', '#fd79a8', '#f0932b'];

        // Variável global para a instância do gráfico de despesas
        let expenseChartInstance = null;

        // --- Funções Auxiliares ---

        // Função para gerar UUIDs (IDs únicos)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Formata um valor numérico para moeda brasileira
        function formatCurrency(value) {
            return parseFloat(value).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
        }

        // Limpa e formata o input de valor para moeda brasileira
        function formatCurrencyInput(inputElement) {
            let value = inputElement.value.replace(/\D/g, ''); 
            
            if (value.length === 0) {
                inputElement.value = '';
                return;
            }

            value = (parseInt(value, 10) / 100).toFixed(2); 
            value = value.replace('.', ','); 
            value = value.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.'); 

            inputElement.value = value;
        }

        // Helper para pegar o mês atual no formato 'YYYY-MM'
        function getCurrentMonthYYYYMM() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            return `${year}-${month}`;
        }

        // NOVO: Função para escapar crases e sequências de interpolação de template em strings
        function escapeTemplateLiterals(str) {
            // Ensure str is a string. If it's null, undefined, or a number, convert it.
            if (typeof str !== 'string') {
                str = String(str);
            }
            return str.replace(/`/g, '\\`').replace(/\$\{/g, '\\${');
        }

        // JavaScript para simular a navegação entre as seções/páginas
        document.addEventListener('DOMContentLoaded', async () => {
            // Elementos do Modal de Confirmação Genérico
            const confirmationModal = document.getElementById('confirmation-modal');
            const confirmationModalTitle = document.getElementById('confirmation-modal-title');
            const confirmationModalMessage = document.getElementById('confirmation-modal-message');
            const cancelConfirmationButton = document.getElementById('cancel-confirmation-button');
            const confirmActionButton = document.getElementById('confirm-action-button');
            let confirmActionCallback = null; // Função a ser executada ao confirmar

            // Seleciona todos os elementos que podem atuar como links de navegação.
            const navLinks = document.querySelectorAll('.nav-link, .mobile-nav-item, [data-page]');
            const pageSections = document.querySelectorAll('.page-section');

            // Função para exibir um modal de confirmação customizado
            function showConfirmationModal(title, message, callback) {
                confirmationModalTitle.textContent = title;
                confirmationModalMessage.textContent = message;
                confirmActionCallback = callback;
                confirmationModal.classList.add('active');
            }

            // Função para fechar o modal de confirmação
            function closeConfirmationModal() {
                confirmationModal.classList.remove('active');
                confirmActionCallback = null; // Limpa o callback
            }

            // Event listener para o botão de confirmar no modal de confirmação
            confirmActionButton.addEventListener('click', () => {
                if (confirmActionCallback) {
                    confirmActionCallback();
                }
                closeConfirmationModal();
            });

            // Event listener para o botão de cancelar no modal de confirmação
            cancelConfirmationButton.addEventListener('click', closeConfirmationModal);


            // --- Funções de Persistência (Firebase Firestore) ---
            // Caminhos base para os dados do usuário no Firestore.
            // Função para obter referência a uma coleção (para múltiplos documentos, ex: transações)
            const getUserCollectionRef = (collectionName) => {
                // Certifica-se de que userId está definido antes de criar a referência
                if (!userId) {
                    console.error("userId não está definido. Não é possível criar referência de coleção.");
                    return null;
                }
                return collection(db, `artifacts/${appId}/users/${userId}`, collectionName);
            };

            // Função para obter referência a um documento específico (para dados armazenados como um único doc, ex: categorias, caixinhas, orçamentos, aiConfig)
            const getUserDocumentRef = (collectionName, docName) => {
                // Certifica-se de que userId está definido antes de criar a referência
                if (!userId) {
                    console.error("userId não está definido. Não é possível criar referência de documento.");
                    return null;
                }
                return doc(db, `artifacts/${appId}/users/${userId}`, collectionName, docName);
            };

            // Elementos do Chat
            const chatMessagesDiv = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('chat-send-button'); 
            const chatLoadingIndicator = document.getElementById('chat-loading-indicator');
            const refreshChatDataButton = document.getElementById('refresh-chat-data-button');
            const clearChatButton = document.getElementById('clear-chat-button'); // NOVO: Botão Limpar Chat

            // Elementos das Categorias
            const addCategoryButton = document.getElementById('add-new-category-button');
            const categoryListContainer = document.getElementById('category-list-container');
            const categoryModal = document.getElementById('category-modal');
            const closeCategoryModalButton = document.getElementById('close-category-modal');
            const cancelCategoryButton = document.getElementById('cancel-category-button');
            const categoryForm = document.getElementById('category-form');
            const categoryIdInput = document.getElementById('category-id');
            const categoryNameInput = document.getElementById('category-name');
            const categoryModalTitle = document.getElementById('category-modal-title');
            const categoryTypeRadios = document.querySelectorAll('input[name="category-type"]'); 
            const priorityField = document.getElementById('priority-field'); 
            const categoryPriorityRadios = document.querySelectorAll('input[name="category-priority']"); 
            const categorySearchInput = document.getElementById('category-search-input');
            const categorySaveStatusMessage = document.getElementById('category-save-status-message');
            // NOVO: Elementos para o campo de Valor Alvo da Categoria/Caixinha
            const targetAmountField = document.getElementById('target-amount-field');
            const categoryTargetAmountInput = document.getElementById('category-target-amount');


            // Elementos das Transações
            const addNewTransactionButton = document.getElementById('add-new-transaction-button');
            const transactionModal = document.getElementById('transaction-modal');
            const closeTransactionModalButton = document.getElementById('close-transaction-modal');
            const transactionForm = document.getElementById('transaction-form');
            const transactionIdInput = document.getElementById('transaction-id');
            const transactionDescriptionInput = document.getElementById('transaction-description');
            const transactionAmountInput = document.getElementById('transaction-amount');
            const transactionDateInput = document.getElementById('transaction-date');
            // Os radios de transaction-type agora são ocultos e controlados pelos botões da Etapa 1
            const transactionTypeRadios = document.querySelectorAll('input[name="transaction-type"]'); 
            const transactionCategorySelect = document.getElementById('transaction-category');
            // ATUALIZADO: Removido o select, agora é um div para botões de rádio
            const transactionStatusOptionsContainer = document.getElementById('transaction-status-options'); 
            const step2Title = document.getElementById('step-2-title'); // Título da Etapa 2
            const noTransactionsMessage = document.getElementById('no-transactions-message');
            const transactionsListContainer = document.getElementById('transactions-list-container');


            // NOVO: Variáveis de controle para o fluxo multi-etapas do modal de transação
            let currentStep = 1;
            const totalSteps = 4;
            const transactionSteps = [
                document.getElementById('transaction-step-1'),
                document.getElementById('transaction-step-2'),
                document.getElementById('transaction-step-3'),
                document.getElementById('transaction-step-4')
            ];


            // Elementos do Dashboard
            const dashboardCurrentBalance = document.getElementById('dashboard-current-balance');
            const dashboardMonthlyIncome = document.getElementById('dashboard-monthly-income');
            const dashboardMonthlyExpenses = document.getElementById('dashboard-monthly-expenses');

            // Elementos da Seção de Transações (Resumo)
            const transactionsCurrentBalance = document.getElementById('transactions-current-balance');
            const transactionsTotalExpenses = document.getElementById('transactions-total-expenses');
            const transactionsTotalCaixinhasSaved = document.getElementById('transactions-total-caixinhas-saved'); 

            // Elementos do Orçamento
            const configureBudgetButton = document.getElementById('configure-budget-button'); 
            const optimizeBudgetButton = document.getElementById('optimize-budget-button'); 
            const budgetListContainer = document.getElementById('budget-list-container');
            const noBudgetsMessage = document.getElementById('no-budgets-message');

            // Elementos do Insights Modal
            const insightsModal = document.getElementById('insights-modal');
            const closeInsightsModalButton = document.getElementById('close-insights-modal'); 
            const closeInsightsButton = document.getElementById('close-insights-button');
            const insightsContent = document.getElementById('insights-content');
            const insightsLoadingIndicator = document.getElementById('insights-loading-indicator');
            const insightsText = document.getElementById('insights-text');

            // Elementos do Modal de Otimização de Orçamento
            const budgetOptimizationModal = document.getElementById('budget-optimization-modal');
            const closeBudgetOptimizationModalButton = document.getElementById('budget-optimization-modal');
            const closeBudgetOptimizationButton = document.getElementById('close-budget-optimization-button');
            const budgetOptimizationContent = document.getElementById('budget-optimization-content');
            const budgetOptimizationLoadingIndicator = document.getElementById('budget-optimization-loading-indicator');
            const budgetOptimizationText = document.getElementById('budget-optimization-text');


            // Elementos do Modal de Chave de API (ATUALIZADO PARA 5 CAMPOS)
            const apiManagementLink = document.querySelector('[data-page="api-management"]');
            const apiKeysModal = document.getElementById('api-keys-modal');
            const closeApiKeysModalButton = document.getElementById('close-api-keys-modal');
            const modalApiKeyInputs = [ // Array de inputs para as 5 chaves
                document.getElementById('modal-api-key-1'),
                document.getElementById('modal-api-key-2'),
                document.getElementById('modal-api-key-3'),
                document.getElementById('modal-api-key-4'),
                document.getElementById('modal-api-key-5')
            ];
            const saveApiKeysModalButton = document.getElementById('save-api-keys-modal-button');
            const apiModalStatusMessageDiv = document.getElementById('api-modal-status-message');
            const apiModalMessageText = document.getElementById('api-modal-message-text');

            // Elementos da Configuração de IA (ATUALIZADOS)
            const aiPersonaInput = document.getElementById('ai-persona');
            const aiPersonalityInput = document.getElementById('ai-personality'); // NOVO ELEMENTO
            const aiConfigStatusMessage = document.getElementById('ai-config-status-message');
            const saveAiConfigButton = document.getElementById('save-ai-config-button'); // NOVO: Botão Salvar Configurações

            // Elementos do novo Modal de Orçamento
            const budgetModal = document.getElementById('budget-modal');
            const closeBudgetModalButton = document.getElementById('close-budget-modal');
            const cancelBudgetButton = document.getElementById('cancel-budget-button');
            const budgetForm = document.getElementById('budget-form');
            const budgetIdInput = document.getElementById('budget-id');
            const budgetCategorySelect = document.getElementById('budget-category');
            const budgetAmountInput = document.getElementById('budget-amount');
            const budgetModalTitle = document.getElementById('budget-modal-title');


            // Botões de Sair
            const logoutButtonDesktop = document.getElementById('logout-button-desktop');
            const logoutButtonMobile = document.getElementById('logout-button-mobile');

            // Carrega todos os dados do Firestore
            async function loadAllDataFromFirestore() {
                console.log("loadAllDataFromFirestore called. userId:", userId, "isAuthReady:", isAuthReady);
                if (!isAuthReady || !userId) {
                    console.warn("Autenticação não pronta ou userId ausente para carregar dados do Firestore. Abortando load.");
                    return;
                }

                // Listener para AI Config - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('settings', 'aiConfig'), (docSnap) => {
                    if (docSnap.exists()) {
                        aiConfig = { ...aiConfig, ...docSnap.data() }; // Mescla com os defaults
                    }
                    // Popula os campos da UI com os valores carregados ou padrão
                    aiPersonaInput.value = aiConfig.persona;
                    aiPersonalityInput.value = aiConfig.personality; // Popula o novo campo
                    
                    if (!docSnap.exists()) {
                        console.log("AI Config não encontrada, salvando padrão.");
                        // Não salva automaticamente aqui, apenas inicializa a variável global
                        // O salvamento inicial será feito pelo clique no botão Salvar
                    }
                }, (error) => {
                    console.error("Erro ao carregar AI Config do Firestore:", error);
                });

                // Listener para Categorias (que agora incluem Caixinhas) - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('categories', 'userCategories'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().items) {
                        categories = docSnap.data().items;
                        console.log("Categorias e Caixinhas carregadas do Firestore.");
                        renderCategories(categorySearchInput.value);
                        updateDashboardAndTransactionSummaries(); // Atualiza os resumos após carregar categorias
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    } else { // Se não existir ou estiver vazio, inicializa como array vazio
                        categories = [];
                        console.log("Categorias e Caixinhas não encontradas ou vazias, inicializando como array vazio.");
                        saveCategories(); // Salva para criar o documento vazio se não existir
                        renderCategories(categorySearchInput.value);
                        updateDashboardAndTransactionSummaries();
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    }
                }, (error) => {
                    console.error("Erro ao carregar Categorias do Firestore:", error);
                });

                // Listener para Orçamentos - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('budgets', 'userBudgets'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().items) {
                        budgets = docSnap.data().items;
                        console.log("Orçamentos carregados do Firestore.");
                        renderBudgets();
                    } else { // Se não existir ou estiver vazio, inicializa como array vazio
                        budgets = [];
                        console.log("Orçamentos não encontrados ou vazios, inicializando como array vazio.");
                        saveBudgets(); // Salva para criar o documento vazio se não existir
                        renderBudgets();
                    }
                }, (error) => {
                    console.error("Erro ao carregar Orçamentos do Firestore:", error);
                });

                // Listener para Chaves de API Gemini (ARRAY) - NOVO
                onSnapshot(getUserDocumentRef('settings', 'geminiApiKeys'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().keys && Array.isArray(docSnap.data().keys)) {
                        geminiApiKeys = docSnap.data().keys;
                        // Popula os campos do modal com as chaves salvas
                        modalApiKeyInputs.forEach((input, index) => {
                            input.value = geminiApiKeys[index] || '';
                        });
                        updateApiModalStatus("Chaves de API carregadas.", "info");
                        isGeminiApiReady = geminiApiKeys.some(key => key.trim() !== ''); // Pronto se houver qualquer chave
                        console.log("Chaves de API Gemini carregadas do Firestore.");
                    } else {
                        geminiApiKeys = [];
                        modalApiKeyInputs.forEach(input => input.value = ''); // Limpa os campos
                        updateApiModalStatus("Nenhuma chave de API salva ainda. Por favor, insira e salve.", "info");
                        isGeminiApiReady = false;
                        console.log("Chaves de API Gemini não encontradas no Firestore.");
                    }
                    updateChatUIState();
                }, (error) => {
                    console.error("Erro ao carregar Chaves de API Gemini do Firestore:", error);
                    geminiApiKeys = [];
                    updateApiModalStatus(`Erro ao carregar chaves de API: ${error.message}`, "error");
                    isGeminiApiReady = false;
                    updateChatUIState();
                });

                // Listener para Transações - Usa getUserCollectionRef
                const transactionsColRef = getUserCollectionRef('transactions');
                if (transactionsColRef) { // Verifica se a referência foi criada com sucesso
                    onSnapshot(query(transactionsColRef, orderBy('date', 'desc')), (querySnapshot) => {
                        transactions = [];
                        querySnapshot.forEach((doc) => {
                            transactions.push({ id: doc.id, ...doc.data() });
                        });
                        console.log("Transações carregadas do Firestore.");
                        renderTransactions();
                        updateDashboardAndTransactionSummaries();
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    }, (error) => {
                        console.error("Erro ao carregar Transações do Firestore:", error);
                    });
                }
            }

            // Função para exibir o status de salvamento (NOVO)
            function showAiConfigSaveStatus() {
                aiConfigStatusMessage.classList.remove('hidden');
                setTimeout(() => {
                    aiConfigStatusMessage.classList.add('hidden');
                }, 2000); // A mensagem desaparece após 2 segundos
            }

            // Salva a configuração da IA no Firestore (ATUALIZADO)
            async function saveAiConfig() {
                if (!isAuthReady || !userId) {
                    console.warn("Autenticação não pronta ou userId ausente.");
                    return;
                }
                try {
                    const aiConfigRef = getUserDocumentRef('settings', 'aiConfig');
                    if (aiConfigRef) {
                        await setDoc(aiConfigRef, aiConfig, { merge: true }); // Usar merge para não sobrescrever
                        showAiConfigSaveStatus();
                        console.log("Configurações da IA salvas automaticamente.");
                    }
                } catch (error) {
                    console.error("Erro ao salvar AI Config:", error);
                    // Não exibe mensagem de erro na UI para auto-save, apenas no console
                }
            }

            // NOVO: Função para salvar manualmente as configurações da IA
            async function manualSaveAiConfig() {
                aiConfig.persona = aiPersonaInput.value;
                aiConfig.personality = aiPersonalityInput.value;
                await saveAiConfig();
            }

            // Salva categorias no Firestore (como um único documento com array)
            // Agora lida com categorias normais e caixinhas
            async function saveCategories() {
                if (!isAuthReady || !userId) { 
                    console.warn("saveCategories: Autenticação não pronta ou userId ausente. Tentando salvar localmente por agora.");
                    displayCategorySaveStatus('Erro: Autenticação não pronta para salvar no banco.', 'error');
                    return; 
                }
                try {
                    const userCategoriesRef = getUserDocumentRef('categories', 'userCategories');
                    if (userCategoriesRef) {
                        await setDoc(userCategoriesRef, { items: categories || [] }); 
                        console.log("saveCategories: Categorias e Caixinhas salvas com sucesso no Firestore!");
                        displayCategorySaveStatus('Categoria/Caixinha salva com sucesso! &#x1F389;', 'success');
                    }
                } catch (error) {
                    console.error("saveCategories: Erro ao salvar Categorias no Firestore:", error);
                    displayCategorySaveStatus(`Erro ao salvar: ${error.message}`, 'error');
                }
            }

            // Salva uma transação individual no Firestore (adicione ou atualize)
            async function saveTransaction(transactionData) {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    const transactionsColRef = getUserCollectionRef('transactions');
                    if (transactionsColRef) {
                        if (transactionData.id) {
                            await setDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions`, transactionData.id), transactionData);
                        } else {
                            await addDoc(transactionsColRef, transactionData);
                        }
                    }
                } catch (error) {
                    console.error("Erro ao salvar Transação:", error);
                }
            }

            // Deleta uma transação individual do Firestore
            async function deleteTransactionFromFirestore(id) {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions`, id));
                } catch (error) {
                    console.error("Erro ao deletar Transação:", error);
                }
            }

            // Salva orçamentos no Firestore (como um único documento com array)
            async function saveBudgets() {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    const userBudgetsRef = getUserDocumentRef('budgets', 'userBudgets');
                    if (userBudgetsRef) {
                        await setDoc(userBudgetsRef, { items: budgets || [] }); 
                    }
                } catch (error) {
                    console.error("Erro ao salvar Orçamentos:", error);
                }
            }

            // Salva as chaves da API Gemini no Firestore (ARRAY) - ATUALIZADO
            async function saveApiKeys() {
                if (!isAuthReady || !userId) { 
                    updateApiModalStatus("Erro: Autenticação não pronta para salvar as chaves de API.", "error");
                    return; 
                }
                const keysToSave = modalApiKeyInputs.map(input => input.value.trim());
                
                // Validação simples: pelo menos uma chave deve ser preenchida
                if (keysToSave.every(key => key === '')) {
                    updateApiModalStatus("Por favor, insira pelo menos uma chave de API válida.", "error");
                    return;
                }

                try {
                    const apiKeyRef = getUserDocumentRef('settings', 'geminiApiKeys');
                    if (apiKeyRef) {
                        await setDoc(apiKeyRef, { keys: keysToSave });
                        geminiApiKeys = keysToSave; // Atualiza o array local
                        updateApiModalStatus("Chaves de API salvas com sucesso! &#x1F389;", "success");
                        isGeminiApiReady = geminiApiKeys.some(key => key.trim() !== '');
                        updateChatUIState();
                        console.log("Chaves de API Gemini salvas no Firestore.");
                    }
                } catch (error) {
                    console.error("Erro ao salvar Chaves de API Gemini no Firestore:", error);
                    updateApiModalStatus(`Erro ao salvar chaves de API: ${error.message}`, "error");
                }
            }
            // --- FIM das Funções de Persistência (Firebase Firestore) ---

            // Adiciona um try-catch para a inicialização do Firebase
            try {
                await initializeFirebase();
            } catch (error) {
                console.error("Erro fatal na inicialização do Firebase:", error);
                document.body.innerHTML = '<div class="flex items-center justify-center min-h-screen bg-red-100 text-red-800 p-4 rounded-lg shadow-md">' +
                                          '<p class="text-lg font-semibold">Erro crítico: Não foi possível carregar o aplicativo. Por favor, tente novamente mais tarde ou contate o suporte.</p>' +
                                          '</div>';
            }
            
            // A função loadApiKey agora é disparada pelo onSnapshot dentro de loadAllDataFromFirestore
            // e não precisa mais ser chamada explicitamente aqui ou em openApiKeysModal.
            // A UI de chat será atualizada pelo onSnapshot da chave de API.

            // --- Funções de UI e Navegação ---

            // Função para exibir a página correta
            function showPage(pageId) {
                pageSections.forEach(section => {
                    section.classList.remove('active');
                });
                const activePage = document.getElementById(pageId);
                if (activePage) {
                    activePage.classList.add('active');
                }

                // Atualizar o estado ativo dos links de navegação
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.dataset.page === pageId && (link.classList.contains('nav-link') || link.classList.contains('mobile-nav-item'))) {
                        link.classList.add('active');
                    }
                });

                // Ações específicas ao carregar cada página
                if (pageId === 'chat') {
                    chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
                } else if (pageId === 'categories-management') {
                    renderCategories();
                } else if (pageId === 'transactions') {
                    renderTransactions();
                    updateDashboardAndTransactionSummaries();
                } 
                else if (pageId === 'dashboard') {
                    updateDashboardAndTransactionSummaries();
                    renderExpenseChart(); // Garante que o gráfico é renderizado ao voltar para o dashboard
                } else if (pageId === 'budget-management') {
                    renderBudgets();
                } else if (pageId === 'ai-config') {
                    // Os valores já são populados pelo onSnapshot, mas garantimos que os campos estão corretos.
                    aiPersonaInput.value = aiConfig.persona;
                    aiPersonalityInput.value = aiConfig.personality; // Popula o novo campo
                }
            }

            // Função para atualizar os cards de resumo no Dashboard e Transações
            function updateDashboardAndTransactionSummaries() {
                let totalIncome = 0;
                let totalExpenses = 0;
                let currentBalance = 0;

                transactions.forEach(t => {
                    // Determina o tipo de transação para cálculo de saldo
                    let effectiveType = t.type;
                    if (t.type === 'caixinha') {
                        effectiveType = t.transactionType === 'deposit' ? 'expense' : 'income'; // Depósito é uma "despesa" do saldo principal, resgate é uma "receita"
                    }

                    if (effectiveType === 'income' && (t.status === 'Recebido' || t.status === 'Pago' || t.status === 'Confirmado')) { 
                        totalIncome += parseFloat(t.amount);
                    } else if (effectiveType === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')) { 
                        totalExpenses += parseFloat(t.amount);
                    }
                });
                currentBalance = totalIncome - totalExpenses;

                // Atualiza Dashboard
                dashboardCurrentBalance.textContent = formatCurrency(currentBalance);
                dashboardMonthlyIncome.textContent = formatCurrency(totalIncome);
                dashboardMonthlyExpenses.textContent = formatCurrency(totalExpenses);

                // Atualiza Resumo em Transações
                transactionsCurrentBalance.textContent = formatCurrency(currentBalance);
                transactionsTotalExpenses.textContent = formatCurrency(totalExpenses);

                // Atualiza Total Guardado (Caixinhas) - Agora filtra das categorias
                let totalCaixinhasSaved = categories
                    .filter(cat => cat.type === 'caixinha')
                    .reduce((sum, caixinha) => sum + parseFloat(caixinha.savedAmount || 0), 0); 
                transactionsTotalCaixinhasSaved.textContent = formatCurrency(totalCaixinhasSaved); 
            }


            // --- Funções de Gerenciamento de Categorias ---

            /**
             * Retorna a próxima cor disponível para uma categoria com base no seu tipo e prioridade.
             * A função tenta encontrar uma cor que ainda não esteja em uso por outras categorias
             * do mesmo tipo/prioridade. Se todas as cores da paleta estiverem em uso, ela cicla.
             * @param {string} type - O tipo da categoria ('income', 'expense', 'caixinha').
             * @param {string} [priority] - A prioridade da categoria ('essential', 'non-essential'), aplicável apenas a 'expense'.
             * @returns {string} A cor hexadecimal selecionada.
             */
            function getNextAvailableColor(type, priority = null) {
                let palette;
                if (type === 'income') {
                    palette = INCOME_COLORS;
                } else if (type === 'expense') {
                    palette = (priority === 'essential') ? ESSENTIAL_COLORS : NON_ESSENTIAL_COLORS;
                } else if (type === 'caixinha') {
                    palette = CAIXINHA_COLORS;
                } else {
                    return '#9E9E9E'; // Cor padrão de fallback
                }

                // Filtra as categorias existentes para encontrar as do mesmo tipo/prioridade
                const relevantCategories = categories.filter(cat => {
                    if (cat.type !== type) return false;
                    if (type === 'expense' && cat.priority !== priority) return false;
                    return true;
                });

                const usedColors = new Set(relevantCategories.map(cat => cat.color));

                // Tenta encontrar uma cor não utilizada
                for (const color of palette) {
                    if (!usedColors.has(color)) {
                        return color;
                    }
                }

                // Se todas foram usadas, reutiliza de forma cíclica
                return palette[relevantCategories.length % palette.length];
            }

            // Função para renderizar as categorias (e caixinhas) na lista
            function renderCategories(filter = '') {
                categoryListContainer.innerHTML = '';

                const filteredCategories = categories.filter(cat => 
                    cat.name.toLowerCase().includes(filter.toLowerCase())
                );

                if (filteredCategories.length === 0 && filter === '') {
                    categoryListContainer.innerHTML = '<p class="text-center text-gray-500 py-4">Nenhuma categoria ou caixinha cadastrada. Adicione uma nova!</p>';
                } else if (filteredCategories.length === 0 && filter !== '') {
                    categoryListContainer.innerHTML = `<p class="text-center text-gray-500 py-4">Nenhuma categoria ou caixinha encontrada para "${filter}".</p>`;
                }

                filteredCategories.forEach(category => {
                    const categoryItem = document.createElement('div');
                    categoryItem.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
                    
                    let typeDisplay = '';
                    let priorityDisplay = '';
                    let savedAmountDisplay = '';
                    let progressHtml = '';

                    if (category.type === 'income') {
                        typeDisplay = 'Receita';
                    } else if (category.type === 'expense') {
                        typeDisplay = 'Despesa';
                        priorityDisplay = category.priority ? ` (${category.priority === 'essential' ? 'Essencial' : 'Não Essencial'})` : '';
                    } else if (category.type === 'caixinha') {
                        typeDisplay = 'Caixinha';
                        const saved = parseFloat(category.savedAmount || 0);
                        const target = parseFloat(category.targetAmount || 0);
                        const progress = (target > 0) ? (saved / target) * 100 : 0;
                        const progressBarColor = progress >= 100 ? 'bg-green-500' : (progress > 50 ? 'bg-blue-500' : 'bg-yellow-500');

                        savedAmountDisplay = ` - Guardado: ${formatCurrency(saved)} / Alvo: ${formatCurrency(target)}`;
                        progressHtml = `
                            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 mt-2">
                                <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${Math.min(100, progress)}%"></div>
                            </div>
                            <p class="text-xs text-gray-500 mt-1">${progress.toFixed(0)}% Concluído</p>
                        `;
                    }

                    categoryItem.innerHTML = `
                        <div class="flex items-center">
                            <div class="w-6 h-6 rounded-full mr-3" style="background-color: ${category.color};"></div>
                            <div>
                                <p class="font-medium text-lg">${escapeTemplateLiterals(category.name)}</p>
                                <p class="text-sm text-gray-500">${typeDisplay}${priorityDisplay}${savedAmountDisplay}</p>
                                ${progressHtml}
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button class="text-gray-500 hover:text-blue-500 p-1 rounded-full edit-category-button" data-id="${category.id}">
                                <i class="fa-solid fa-pen-to-square text-lg"></i>
                            </button>
                            <button class="text-gray-500 hover:text-red-500 p-1 rounded-full delete-category-button" data-id="${category.id}">
                                <i class="fa-solid fa-trash-can text-lg"></i>
                            </button>
                        </div>
                    `;
                    categoryListContainer.appendChild(categoryItem);
                });
            }

            // Abre o modal de categoria (agora também para caixinhas)
            function openCategoryModal(category = null) {
                categoryModal.classList.add('active');
                categorySaveStatusMessage.classList.add('hidden');
                categoryForm.reset(); // Limpa o formulário
                categoryTargetAmountInput.value = ''; // Limpa o campo de valor alvo

                if (category) {
                    categoryModalTitle.textContent = 'Editar Categoria';
                    categoryIdInput.value = category.id;
                    categoryNameInput.value = category.name;
                    document.querySelector(`input[name="category-type"][value="${category.type}"]`).checked = true;
                    
                    // Controla a visibilidade do campo de prioridade
                    if (category.type === 'expense') {
                        priorityField.style.display = 'block';
                        document.querySelector(`input[name="category-priority"][value="${category.priority || 'essential'}"]`).checked = true;
                    } else {
                        priorityField.style.display = 'none';
                    }

                    // Controla a visibilidade e preenche o campo de valor alvo para caixinhas
                    if (category.type === 'caixinha') {
                        targetAmountField.style.display = 'block';
                        categoryTargetAmountInput.value = (parseFloat(category.targetAmount || 0) * 100).toFixed(0);
                        formatCurrencyInput(categoryTargetAmountInput); // Formata o valor
                    } else {
                        targetAmountField.style.display = 'none';
                    }

                } else { // Adicionar nova categoria/caixinha
                    categoryModalTitle.textContent = 'Adicionar Nova Categoria ou Caixinha';
                    categoryIdInput.value = '';
                    categoryNameInput.value = '';
                    document.querySelector('input[name="category-type"][value="expense"]').checked = true; // Padrão para Despesa
                    priorityField.style.display = 'block'; // Visível por padrão para despesa
                    document.querySelector(`input[name="category-priority"][value="essential"]`).checked = true;
                    targetAmountField.style.display = 'none'; // Escondido por padrão
                }
            }

            // Fecha o modal de categoria
            function closeCategoryModal() {
                categoryModal.classList.remove('active');
                categoryForm.reset();
                categorySaveStatusMessage.classList.add('hidden');
            }

            // Exibe mensagem de status para salvar categoria
            function displayCategorySaveStatus(message, type = 'info') {
                categorySaveStatusMessage.textContent = message;
                categorySaveStatusMessage.classList.remove('hidden', 'text-green-700', 'text-red-700', 'text-blue-700');
                if (type === 'success') {
                    categorySaveStatusMessage.classList.add('text-green-700');
                } else if (type === 'error') {
                    categorySaveStatusMessage.classList.add('text-red-700');
                } else {
                    categorySaveStatusMessage.classList.add('text-blue-700');
                }
                setTimeout(() => {
                    categorySaveStatusMessage.classList.add('hidden');
                }, 3000);
            }

            // Lida com o envio do formulário de categoria
            categoryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const id = categoryIdInput.value;
                const name = categoryNameInput.value.trim();
                const type = document.querySelector('input[name="category-type"]:checked').value;
                
                if (!name) {
                    displayCategorySaveStatus('O nome da categoria é obrigatório!', 'error');
                    return;
                }
                
                let priority = (type === 'expense') ? document.querySelector('input[name="category-priority"]:checked').value : null;
                let targetAmount = null;
                let savedAmount = null;

                if (type === 'caixinha') {
                    const targetAmountFormatted = categoryTargetAmountInput.value.replace(/\./g, '').replace(',', '.');
                    targetAmount = parseFloat(targetAmountFormatted) || 0;
                    // Se estiver editando uma caixinha existente, mantém o savedAmount
                    if (id) {
                        const existingCategory = categories.find(cat => cat.id === id);
                        savedAmount = existingCategory ? existingCategory.savedAmount : 0;
                    } else {
                        // Se for uma nova caixinha, o valor guardado começa em 0
                        savedAmount = 0;
                    }
                }

                if (id) { // Editando uma categoria existente
                    const index = categories.findIndex(cat => cat.id === id);
                    if (index !== -1) {
                        const originalCategory = categories[index];
                        const mudouTipo = originalCategory.type !== type;
                        const mudouPrioridade = originalCategory.priority !== priority;
                                                
                        // Mantém a cor se o tipo/prioridade não mudar
                        let newColor = originalCategory.color; 
                                                
                        // Recalcula a cor apenas se o tipo ou prioridade mudou
                        if (mudouTipo || mudouPrioridade) {
                            newColor = getNextAvailableColor(type, priority);
                        }
                        categories[index] = { 
                            ...originalCategory, 
                            name, 
                            type, 
                            priority, 
                            color: newColor,
                            targetAmount: targetAmount, // Atualiza targetAmount
                            savedAmount: savedAmount // Atualiza savedAmount
                        };
                    }
                } else { // Criando uma nova categoria
                    const newColor = getNextAvailableColor(type, priority);
                    const newCategory = { 
                        id: generateUUID(), 
                        name, 
                        type, 
                        priority, 
                        color: newColor,
                        targetAmount: targetAmount,
                        savedAmount: savedAmount
                    };
                                        
                    categories.push(newCategory);
                }
                await saveCategories();
                
                if(transactionModal.classList.contains('active')) {
                    // populateTransactionCategories(document.querySelector('input[name="transaction-type']:checked').value); // Removido, a lógica de populate é no goToStep(2)
                }
                closeCategoryModal(); // Fecha o modal após salvar
            });

            // Lida com cliques nos botões de editar/excluir categorias (delegação de eventos)
            categoryListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.edit-category-button')) {
                    const id = e.target.closest('.edit-category-button').dataset.id;
                    const categoryToEdit = categories.find(cat => cat.id === id);
                    if (categoryToEdit) {
                        openCategoryModal(categoryToEdit);
                    }
                } else if (e.target.closest('.delete-category-button')) {
                    const id = e.target.closest('.delete-category-button').dataset.id;
                    const categoryToDelete = categories.find(cat => cat.id === id);

                    showConfirmationModal(
                        "Confirmar Exclusão",
                        `Tem certeza que deseja excluir a categoria "${escapeTemplateLiterals(categoryToDelete.name)}"? Todas as transações associadas a ela ficarão sem categoria.`,
                        async () => {
                            categories = categories.filter(cat => cat.id !== id);
                            const transactionsToUpdate = transactions.filter(t => t.categoryId === id);
                            for (const t of transactionsToUpdate) {
                                t.categoryId = 'unknown'; // Define como categoria desconhecida
                                t.transactionType = null; // Limpa o tipo de transação se for caixinha
                                t.caixinhaId = null; // Limpa o ID da caixinha
                                await saveTransaction(t);
                            }
                            await saveCategories();
                            // if(transactionModal.classList.contains('active')) { // Removido, a lógica de populate é no goToStep(2)
                            //     populateTransactionCategories(document.querySelector('input[name="transaction-type']:checked').value);
                            // }
                            updateDashboardAndTransactionSummaries();
                        }
                    );
                }
            });

            // Lógica para mostrar/esconder o campo de prioridade e valor alvo
            categoryTypeRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const selectedType = event.target.value;
                    // Mostra/esconde campo de prioridade
                    priorityField.style.display = (selectedType === 'expense') ? 'block' : 'none';
                    // Mostra/esconde campo de valor alvo
                    targetAmountField.style.display = (selectedType === 'caixinha') ? 'block' : 'none';
                    // Limpa o valor do campo alvo se não for caixinha
                    if (selectedType !== 'caixinha') {
                        categoryTargetAmountInput.value = '';
                    }
                });
            });

            // Listener para formatar o input de valor alvo da categoria/caixinha
            categoryTargetAmountInput.addEventListener('input', () => {
                formatCurrencyInput(categoryTargetAmountInput);
            });


            // --- Funções de Gerenciamento de Transações ---

            // Função para popular o dropdown de categorias (e caixinhas) no modal de transações
            function populateTransactionCategories(selectedTransactionType = null) {
                transactionCategorySelect.innerHTML = '<option value="">Selecione uma Categoria</option>';

                let filteredCategories = [];
                // A lógica aqui precisa ser inteligente para o novo fluxo:
                // Se for 'income' ou 'expense', filtra por essas categorias.
                // Se for 'deposit' ou 'withdraw', filtra por categorias do tipo 'caixinha'.
                if (selectedTransactionType === 'expense' || selectedTransactionType === 'income') {
                    filteredCategories = categories.filter(cat => cat.type === selectedTransactionType);
                } else if (selectedTransactionType === 'deposit' || selectedTransactionType === 'withdraw') {
                    filteredCategories = categories.filter(cat => cat.type === 'caixinha');
                }

                if (filteredCategories.length > 0) {
                    filteredCategories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.id;
                        option.textContent = cat.name; 
                        transactionCategorySelect.appendChild(option);
                    });
                } else {
                    transactionCategorySelect.innerHTML += '<option value="" disabled>Nenhuma categoria disponível para este tipo</option>';
                }
            }


            // Renderiza as transações
            function renderTransactions() {
                transactionsListContainer.innerHTML = `
                    <div class="absolute left-3 top-0 bottom-0 w-0.5 bg-gray-200"></div>
                `; 

                if (transactions.length === 0) {
                    transactionsListContainer.innerHTML += '<p class="text-center text-gray-500 py-4" id="no-transactions-message">Nenhuma transação cadastrada ainda.</p>';
                    return;
                }

                const groupedTransactions = transactions.reduce((acc, transaction) => {
                    const date = transaction.date;
                    if (!acc[date]) {
                        acc[date] = [];
                    }
                    acc[date].push(transaction);
                    return acc;
                }, {});

                const sortedDates = Object.keys(groupedTransactions).sort((a, b) => new Date(b) - new Date(a));

                sortedDates.forEach(date => {
                    const dateGroupDiv = document.createElement('div');
                    dateGroupDiv.className = 'mb-6 relative pl-8';

                    const formattedDate = new Date(date + 'T12:00:00').toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });

                    dateGroupDiv.innerHTML = `
                        <div class="timeline-bullet-date">
                            <i class="fa-solid fa-calendar-days text-sm"></i>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 ml-2">${formattedDate}</h3>
                        <div class="space-y-3"></div>
                    `;
                    const transactionsForDateDiv = dateGroupDiv.querySelector('.space-y-3');

                    groupedTransactions[date].sort((a, b) => {
                        const dateA = new Date(a.date);
                        const dateB = new Date(b.date);
                        if (dateA.getTime() === dateB.getTime()) {
                            return a.description.localeCompare(b.description);
                        }
                        return dateB - dateA;
                    }).forEach(transaction => {
                        let categoryName = 'Categoria Desconhecida';
                        let bulletColor = '#9E9E9E';
                        let amountColorClass = '';
                        let amountPrefix = '';
                        let transactionTypeDisplay = '';

                        const category = categories.find(cat => cat.id === transaction.categoryId);
                        if (category) {
                            categoryName = category.name;
                            bulletColor = category.color;
                            transactionTypeDisplay = category.type;
                        } else {
                            // Fallback for unknown categories, e.g., after deletion
                            categoryName = 'Categoria Desconhecida';
                            bulletColor = '#9E9E9E';
                            transactionTypeDisplay = transaction.type; // Use transaction's own type if category not found
                        }

                        if (transaction.type === 'income') {
                            amountColorClass = 'text-[var(--color-green-positive)]';
                            amountPrefix = '+';
                        } else if (transaction.type === 'expense') {
                            amountColorClass = 'text-[var(--color-red-negative)]';
                            amountPrefix = '-';
                        } else if (transaction.type === 'caixinha') {
                            if (transaction.transactionType === 'deposit') {
                                amountColorClass = 'text-[var(--color-red-negative)]'; // Saída do saldo principal
                                amountPrefix = '-';
                                categoryName = `Depósito: ${categoryName}`;
                            } else if (transaction.transactionType === 'withdraw') {
                                amountColorClass = 'text-[var(--color-green-positive)]'; // Entrada no saldo principal
                                amountPrefix = '+';
                                categoryName = `Resgate: ${categoryName}`;
                            }
                        }
                        
                        // Determina se a bolinha deve ser preenchida ou vazada
                        const isPaidOrReceived = (transaction.status === 'Pago' || transaction.status === 'Recebido' || transaction.status === 'Confirmado');
                        const bulletClass = isPaidOrReceived ? 'transaction-bullet paid' : 'transaction-bullet';
                        const bulletStyle = isPaidOrReceived ? `background-color: ${bulletColor};` : `border: 3px solid ${bulletColor};`;
                        
                        // NOVO: Status indicator em nova linha, menor e mais suave
                        const statusIndicatorText = transaction.status === 'Pendente' ? 'Pendente' : 
                                                    (transaction.type === 'income' && transaction.status === 'Recebido' ? 'Recebido' : 
                                                    (transaction.type === 'expense' && transaction.status === 'Pago' ? 'Pago' : 
                                                    (transaction.type === 'caixinha' && transaction.transactionType === 'deposit' && transaction.status === 'Confirmado' ? 'Guardado' : 
                                                    (transaction.type === 'caixinha' && transaction.transactionType === 'withdraw' && transaction.status === 'Confirmado' ? 'Resgatado' : ''))));
                        const statusIndicatorHtml = statusIndicatorText ? `<p class="text-xs text-gray-500">${statusIndicatorText}</p>` : '';


                        const transactionItem = document.createElement('div');
                        // Ajustado pl-12 para pl-8
                        transactionItem.className = `bg-white p-4 rounded-lg shadow-sm flex justify-between items-center relative pl-8`; 
                        transactionItem.innerHTML = `
                            <div class="${bulletClass}" style="${bulletStyle}"></div>
                            <div class="flex-grow min-w-0">
                                <p class="font-medium truncate text-gray-800">${escapeTemplateLiterals(categoryName)}</p>
                                ${statusIndicatorHtml} <!-- Status em nova linha -->
                                <p class="text-sm text-gray-500 truncate">${escapeTemplateLiterals(transaction.description)}</p>
                            </div>
                            <div class="flex items-center space-x-2 ml-4">
                                <p class="font-bold text-lg ${amountColorClass}">${amountPrefix} ${formatCurrency(transaction.amount)}</p>
                                <!-- Menu de 3 pontos para Desktop -->
                                <div class="relative hidden md:block">
                                    <button class="transaction-menu-button p-2 rounded-full hover:bg-gray-100" data-id="${transaction.id}">
                                        <i class="fa-solid fa-ellipsis-vertical text-gray-500"></i>
                                    </button>
                                    <div class="transaction-menu-dropdown absolute right-0 mt-2 w-40 bg-white rounded-md shadow-lg z-20 hidden">
                                        <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 edit-transaction-button" data-id="${transaction.id}">Editar</a>
                                        <a href="#" class="block px-4 py-2 text-sm text-red-500 hover:bg-gray-100 delete-transaction-button" data-id="${transaction.id}">Apagar</a>
                                    </div>
                                </div>
                                <!-- Botões para Mobile (visíveis por padrão, swipe seria uma melhoria futura) -->
                                <div class="md:hidden flex space-x-1">
                                    <button class="text-gray-400 hover:text-blue-500 p-1 rounded-full edit-transaction-button" data-id="${transaction.id}">
                                        <i class="fa-solid fa-pen-to-square text-base"></i>
                                    </button>
                                    <button class="text-gray-400 hover:text-red-500 p-1 rounded-full delete-transaction-button" data-id="${transaction.id}">
                                        <i class="fa-solid fa-trash-can text-base"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                        transactionsForDateDiv.appendChild(transactionItem);
                    });
                    transactionsListContainer.appendChild(dateGroupDiv);
                });
                if (transactions.length > 0) {
                    noTransactionsMessage.classList.add('hidden');
                } else {
                    noTransactionsMessage.classList.remove('hidden');
                }
            }

            // Função para atualizar as opções de status com botões de rádio
            function updateTransactionStatusOptions(transactionType) {
                const statusContainer = document.getElementById('transaction-status-options');
                statusContainer.innerHTML = '';
                let options = [];
                if (transactionType === 'income') {
                    options = [{ value: 'Recebido', label: 'Recebido' }, { value: 'Pendente', label: 'Pendente' }];
                } else if (transactionType === 'expense') {
                    options = [{ value: 'Pago', label: 'Pago' }, { value: 'Pendente', label: 'Pendente' }];
                } else { // caixinha (deposit/withdraw)
                    options = [{ value: 'Confirmado', label: 'Confirmado' }]; // Simplificado para caixinhas
                }

                options.forEach((opt, index) => {
                    const wrapper = document.createElement('div');
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'transaction-status-radio'; // Novo nome para evitar conflito com o select removido
                    input.id = `status-${opt.value}`;
                    input.value = opt.value;
                    input.className = 'hidden peer';
                    if (index === 0) input.checked = true; // Marca a primeira opção como padrão

                    const label = document.createElement('label');
                    label.htmlFor = `status-${opt.value}`;
                    label.textContent = opt.label;
                    label.className = 'px-4 py-2 border rounded-lg cursor-pointer transition peer-checked:bg-[var(--color-blue-primary)] peer-checked:text-white peer-checked:border-[var(--color-blue-primary)]';
                    
                    wrapper.appendChild(input);
                    wrapper.appendChild(label);
                    statusContainer.appendChild(wrapper);
                });
            }

            // Função para controlar a visibilidade das etapas do modal de transação
            function goToStep(stepNumber) {
                if (stepNumber < 1 || stepNumber > totalSteps) {
                    console.error("Tentativa de ir para uma etapa inválida:", stepNumber);
                    return;
                }
                currentStep = stepNumber;
                transactionSteps.forEach((step, index) => {
                    step.classList.toggle('hidden', index + 1 !== currentStep);
                });

                // Ações específicas para cada etapa ao navegar
                if (currentStep === 2) {
                    const selectedType = document.querySelector('input[name="transaction-type"]:checked').value;
                    populateTransactionCategories(selectedType);
                    updateTransactionStatusOptions(selectedType); // Atualiza status options para o tipo selecionado
                    transactionAmountInput.focus(); // Foca no campo de valor
                } else if (currentStep === 3) {
                    transactionDescriptionInput.focus(); // Foca no campo de descrição
                } else if (currentStep === 4) {
                    // Seleciona o status correto se estiver editando
                    if (transactionIdInput.value) {
                        const transactionToEdit = transactions.find(t => t.id === transactionIdInput.value);
                        if (transactionToEdit) {
                            const statusRadio = document.querySelector(`input[name="transaction-status-radio"][value="${transactionToEdit.status}"]`);
                            if (statusRadio) {
                                statusRadio.checked = true;
                            }
                        }
                    }
                    // Foca no primeiro botão de rádio de status
                    const firstStatusRadio = transactionStatusOptionsContainer.querySelector('input[type="radio"]');
                    if (firstStatusRadio) {
                        firstStatusRadio.focus();
                    }
                }
            }

            // Abre o modal de transação (agora apenas reseta e vai para a primeira etapa)
            function openTransactionModal(transaction = null) {
                transactionModal.classList.add('active');
                transactionForm.reset();
                transactionDateInput.valueAsDate = new Date(); // Define data padrão
                
                if (transaction) {
                    transactionIdInput.value = transaction.id;
                    transactionDescriptionInput.value = transaction.description;
                    transactionAmountInput.value = (parseFloat(transaction.amount) * 100).toFixed(0);
                    formatCurrencyInput(transactionAmountInput);
                    transactionDateInput.value = transaction.date;

                    // Marca o tipo de transação correto para edição
                    let typeToSelect = transaction.type;
                    if (transaction.type === 'caixinha') {
                        typeToSelect = transaction.transactionType; // 'deposit' ou 'withdraw'
                    }
                    const typeButton = document.querySelector(`.step-1-type-button[data-type="${typeToSelect}"]`);
                    if (typeButton) {
                        document.querySelectorAll('.step-1-type-button').forEach(btn => btn.classList.remove('selected'));
                        typeButton.classList.add('selected');
                        document.querySelector(`input[name="transaction-type"][value="${typeToSelect}"]`).checked = true;
                    }
                    
                    // Preenche a categoria e o status
                    populateTransactionCategories(typeToSelect);
                    transactionCategorySelect.value = transaction.categoryId;
                    updateTransactionStatusOptions(typeToSelect);
                    // O status é marcado na goToStep(4)
                    goToStep(2); // Pula para a etapa 2, que preencherá o restante
                } else {
                    transactionIdInput.value = ''; // Garante que o ID da transação seja limpo para novas transações
                    goToStep(1);
                    // Remove a classe 'selected' de todos os botões de tipo ao abrir o modal
                    document.querySelectorAll('.step-1-type-button').forEach(button => {
                        button.classList.remove('selected');
                    });
                }
            }

            // Fecha o modal de transação
            function closeTransactionModal() {
                transactionModal.classList.remove('active');
                transactionForm.reset();
                currentStep = 1; // Reseta para a primeira etapa ao fechar
            }

            // Lida com o envio do formulário de transação
            transactionForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                // O tipo agora vem do radio button oculto
                const typeSelectedInStep1 = document.querySelector('input[name="transaction-type"]:checked').value;
                
                const id = transactionIdInput.value;
                const description = transactionDescriptionInput.value.trim();
                
                const amountFormatted = transactionAmountInput.value.replace(/\./g, '').replace(',', '.');
                const amount = parseFloat(amountFormatted);

                const date = transactionDateInput.value;
                // ATUALIZADO: Obtém o valor do rádio selecionado
                const status = document.querySelector('input[name="transaction-status-radio"]:checked').value; 
                const categoryId = transactionCategorySelect.value;

                let transactionTypeForCaixinha = null; // 'deposit' or 'withdraw'
                let transactionCategoryType = null; // 'income', 'expense', or 'caixinha'

                // Validação básica (descrição agora é opcional)
                if (isNaN(amount) || !date || !status || !categoryId) {
                    showConfirmationModal("Erro de Validação", "Por favor, preencha todos os campos da transação corretamente (valor, data, status, categoria).", () => {});
                    return;
                }

                // Determina o tipo de transação real ('income', 'expense', 'caixinha')
                // e o tipo de movimento da caixinha ('deposit', 'withdraw')
                const selectedCategory = categories.find(cat => cat.id === categoryId);

                if (!selectedCategory) {
                    console.error("Categoria selecionada não encontrada.");
                    return;
                }

                transactionCategoryType = selectedCategory.type;

                if (selectedCategory.type === 'caixinha') {
                    // Se a categoria é uma caixinha, o 'type' da transação será 'caixinha'
                    // e 'transactionTypeForCaixinha' será 'deposit' ou 'withdraw'
                    if (typeSelectedInStep1 === 'deposit') {
                        transactionTypeForCaixinha = 'deposit';
                        selectedCategory.savedAmount = (selectedCategory.savedAmount || 0) + amount;
                    } else if (typeSelectedInStep1 === 'withdraw') {
                        transactionTypeForCaixinha = 'withdraw';
                        if ((selectedCategory.savedAmount || 0) < amount) {
                            showConfirmationModal(
                                "Erro de Resgate",
                                "O valor que você está tentando resgatar é maior do que o valor guardado nesta caixinha. Por favor, ajuste o valor.",
                                () => {} // Não faz nada ao confirmar, apenas fecha o modal
                            );
                            return; // Impede o salvamento da transação
                        }
                        selectedCategory.savedAmount -= amount;
                    }
                    await saveCategories(); // Salva o estado atualizado das categorias (que inclui a caixinha)
                }

                // Criar ou atualizar a transação
                const newTransaction = { 
                    id: id || generateUUID(), 
                    description, 
                    amount, 
                    date, 
                    type: transactionCategoryType, // Usa o tipo real da categoria
                    categoryId, 
                    status 
                };

                // Adiciona campos específicos para transações de caixinha se aplicável
                if (transactionCategoryType === 'caixinha') {
                    newTransaction.transactionType = transactionTypeForCaixinha;
                    newTransaction.caixinhaId = selectedCategory.id; // O ID da caixinha é o ID da categoria
                }

                await saveTransaction(newTransaction);
                closeTransactionModal();
            });

            // Lida com cliques nos botões de editar/excluir transações (delegação de eventos)
            transactionsListContainer.addEventListener('click', (e) => {
                // Lógica para o menu de 3 pontos (desktop)
                const menuButton = e.target.closest('.transaction-menu-button');
                if (menuButton) {
                    e.stopPropagation(); // Impede que o clique se propague e feche outros menus
                    const dropdown = menuButton.nextElementSibling;
                    // Fecha outros dropdowns abertos
                    document.querySelectorAll('.transaction-menu-dropdown').forEach(openDropdown => {
                        if (openDropdown !== dropdown) {
                            openDropdown.classList.add('hidden');
                        }
                    });
                    dropdown.classList.toggle('hidden');
                    return; // Sai da função para não acionar edit/delete diretamente
                }

                if (e.target.closest('.edit-transaction-button')) {
                    const id = e.target.closest('.edit-transaction-button').dataset.id;
                    const transactionToEdit = transactions.find(t => t.id === id);
                    if (transactionToEdit) {
                        openTransactionModal(transactionToEdit);
                    }
                } else if (e.target.closest('.delete-transaction-button')) {
                    const id = e.target.closest('.delete-transaction-button').dataset.id;
                    showConfirmationModal(
                        "Confirmar Exclusão",
                        "Tem certeza que deseja excluir esta transação?",
                        async () => {
                            const deletedTransaction = transactions.find(t => t.id === id);
                            if (deletedTransaction && deletedTransaction.type === 'caixinha' && deletedTransaction.caixinhaId) {
                                const caixinha = categories.find(c => c.id === deletedTransaction.caixinhaId); // Busca na lista de categorias
                                if (caixinha) {
                                    if (deletedTransaction.transactionType === 'deposit') {
                                        caixinha.savedAmount -= parseFloat(deletedTransaction.amount);
                                    } else if (deletedTransaction.transactionType === 'withdraw') {
                                        caixinha.savedAmount += parseFloat(deletedTransaction.amount);
                                    }
                                    await saveCategories(); // Salva as categorias atualizadas
                                }
                            }
                            await deleteTransactionFromFirestore(id);
                        }
                    );
                }
            });

            // Fecha dropdowns de transação ao clicar fora
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.transaction-menu-button') && !e.target.closest('.transaction-menu-dropdown')) {
                    document.querySelectorAll('.transaction-menu-dropdown').forEach(dropdown => {
                        dropdown.classList.add('hidden');
                    });
                }
            });

            // Listener para formatar o input de valor da transação
            transactionAmountInput.addEventListener('input', () => {
                formatCurrencyInput(transactionAmountInput);
            });


            // --- Funções de Gerenciamento de Orçamento ---
            function openBudgetModal(budget = null) {
                budgetForm.reset();
                budgetCategorySelect.innerHTML = '<option value="">Selecione uma categoria</option>';
                    
                // Popula o select com apenas as categorias de despesa
                const expenseCategories = categories.filter(c => c.type === 'expense');
                expenseCategories.forEach(cat => {
                    // Impede que categorias já orçadas neste mês apareçam para novos orçamentos
                    const isAlreadyBudgeted = budgets.some(b => b.categoryId === cat.id && b.month === getCurrentMonthYYYYMM());
                    if (!budget && isAlreadyBudgeted) return; // Se não estiver editando e já houver orçamento, pula
                    const option = document.createElement('option');
                    option.value = cat.id;
                    option.textContent = cat.name;
                    budgetCategorySelect.appendChild(option);
                });

                if (budget) {
                    budgetModalTitle.textContent = 'Editar Orçamento';
                    budgetIdInput.value = budget.id;
                    budgetCategorySelect.value = budget.categoryId;
                    budgetCategorySelect.disabled = true; // Não permite mudar a categoria na edição
                    budgetAmountInput.value = (parseFloat(budget.amount) * 100).toFixed(0); // Coloca em centavos para formatCurrencyInput
                    formatCurrencyInput(budgetAmountInput); // Formata o valor
                } else {
                    budgetModalTitle.textContent = 'Novo Orçamento Mensal';
                    budgetIdInput.value = '';
                    budgetCategorySelect.disabled = false;
                }
                budgetModal.classList.add('active');
            }

            function closeBudgetModal() {
                budgetModal.classList.remove('active');
            }

            function renderBudgets() {
                budgetListContainer.innerHTML = '';
                const currentMonthBudgets = budgets.filter(b => b.month === getCurrentMonthYYYYMM());
                if (currentMonthBudgets.length === 0) {
                    budgetListContainer.innerHTML = '<p class="text-center text-gray-500 py-4 col-span-full">Nenhum orçamento configurado para este mês.</p>';
                    return;
                }
                noBudgetsMessage.classList.add('hidden'); // Esconde a mensagem se houver orçamentos

                currentMonthBudgets.forEach(budget => {
                    const category = categories.find(c => c.id === budget.categoryId);
                    if (!category) return; // Pula se a categoria foi deletada
                    
                    // Calcula o gasto real para essa categoria no mês corrente
                    const totalSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && 
                            t.type === 'expense' && // Apenas despesas
                            t.date.startsWith(getCurrentMonthYYYYMM()) &&
                            (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado') // Apenas transações pagas/recebidas
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);

                    const progress = budget.amount > 0 ? (totalSpent / budget.amount) * 100 : 0;
                    const remaining = budget.amount - totalSpent;
                    const progressBarColor = progress >= 100 ? 'bg-red-500' : (progress > 80 ? 'bg-yellow-500' : 'bg-green-500');
                    
                    const budgetCard = document.createElement('div');
                    budgetCard.className = 'bg-white p-4 rounded-lg shadow-md flex flex-col justify-between';
                    budgetCard.innerHTML = `
                        <div>
                            <div class="flex items-center mb-2">
                                <div class="w-4 h-4 rounded-full mr-2" style="background-color: ${category.color};"></div>
                                <p class="font-semibold text-lg">${escapeTemplateLiterals(category.name)}</p>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 my-2">
                                <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${Math.min(100, progress)}%;"></div>
                            </div>
                            <div class="text-xs flex justify-between">
                                <span class="text-gray-600">${formatCurrency(totalSpent)} de ${formatCurrency(budget.amount)}</span>
                                <span class="font-bold ${remaining < 0 ? 'text-red-500' : 'text-green-600'}">${progress.toFixed(0)}%</span>
                            </div>
                        </div>
                        <div class="flex justify-end mt-3">
                            <button class="text-gray-500 hover:text-blue-500 p-1 rounded-full edit-budget-button" data-id="${budget.id}">
                                <i class="fa-solid fa-pen-to-square"></i>
                            </button>
                            <button class="text-gray-500 hover:text-red-500 p-1 rounded-full delete-budget-button" data-id="${budget.id}">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </div>
                    `;
                    budgetListContainer.appendChild(budgetCard);
                });
            }

            // --- Funções de Otimização de Orçamento com IA (NOVA) ---
            async function openBudgetOptimizationModal() {
                budgetOptimizationModal.classList.add('active');
                budgetOptimizationText.innerHTML = '';
                budgetOptimizationLoadingIndicator.classList.remove('hidden');

                const activeApiKey = getActiveGeminiApiKey();
                if (!isGeminiApiReady || !activeApiKey) {
                    budgetOptimizationText.innerHTML = '<p class="text-red-500">O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".</p>';
                    budgetOptimizationLoadingIndicator.classList.add('hidden');
                    return;
                }

                let budgetDataString = "";
                if (budgets.length > 0) {
                    budgetDataString += "<strong>Orçamentos configurados:</strong><br><br>";
                    budgets.forEach(budget => {
                        const category = categories.find(c => c.id === budget.categoryId);
                        const categoryName = category ? escapeTemplateLiterals(category.name) : 'Categoria Desconhecida';
                        const actualSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && t.type === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                        const remaining = budget.amount - actualSpent; // Use budget.amount
                        budgetDataString += `- Categoria: ${categoryName}, Orçado: ${formatCurrency(budget.amount)}, Gasto Real: ${formatCurrency(actualSpent)}, Saldo: ${formatCurrency(remaining)}<br>`;
                    });
                } else {
                    budgetDataString += "Nenhum orçamento configurado. Por favor, configure alguns orçamentos para obter sugestões.<br>";
                }
                budgetDataString += "<br>--- Fim dos Dados de Orçamento ---<br><br>";

                const optimizationPrompt =
                    `Com base nos seguintes dados de orçamento do usuário, forneça sugestões claras e acionáveis para otimizar os gastos e gerenciar melhor o dinheiro. ` +
                    `Seja direto, prático e objetivo, como um consultor financeiro que não hesita em apontar onde o usuário pode melhorar. ` +
                    `Use títulos em negrito (<strong>), listas não ordenadas (<ul>, <li>) e quebras de linha (<br>). ` +
                    `NUNCA use Markdown (*, **, _, #, etc.). ` +
                    `Aqui estão os dados: <br><br>${budgetDataString}`; // CORRIGIDO: Usando budgetDataString

                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: optimizationPrompt }] }],
                        generationConfig: {
                            temperature: 0.5, // Temperatura fixa para otimização
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        budgetOptimizationText.innerHTML = aiResponseText;
                    } else if (result.error) {
                        budgetOptimizationText.innerHTML = `<p class="text-red-500">Erro da API: ${result.error.message || 'Erro desconhecido da API Gemini.'}</p>`;
                        console.error('Erro da API Gemini para Otimização de Orçamento:', result.error);
                    } else {
                        budgetOptimizationText.innerHTML = '<p class="text-red-500">Não foi possível gerar sugestões de otimização de orçamento neste momento.</p>';
                    }
                } catch (error) {
                    budgetOptimizationText.innerHTML = `<p class="text-red-500">Erro ao comunicar com a IA para otimização. Verifique sua conexão. Detalhes: ${error.message || 'Erro desconhecido'}</p>`;
                    console.error('Erro ao chamar a API Gemini para Otimização de Orçamento:', error);
                } finally {
                    budgetOptimizationLoadingIndicator.classList.add('hidden');
                }
            }

            function closeBudgetOptimizationModal() {
                budgetOptimizationModal.classList.remove('active');
            }


            // --- Funções do Chat com IA ---
            function appendMessage(sender, text, type = 'text') {
                const messageDiv = document.createElement('div');
                const bubbleDiv = document.createElement('div');

                if (sender === 'user') {
                    messageDiv.className = 'flex justify-end';
                    bubbleDiv.className = 'bg-[var(--color-blue-primary)] text-white p-3 rounded-xl rounded-br-none max-w-xs md:max-w-md shadow-sm';
                } else { // sender === 'ai' or 'model'
                    messageDiv.className = 'flex justify-start';
                    bubbleDiv.className = 'bg-gray-100 text-gray-800 p-3 rounded-xl rounded-bl-none max-w-xs md:max-w-md shadow-sm';
                    if (type === 'error') {
                        bubbleDiv.classList.add('bg-red-100', 'text-red-700', 'border', 'border-red-400');
                    }
                }

                // Usamos innerHTML para renderizar tags HTML básicas que o modelo de IA pode gerar
                bubbleDiv.innerHTML = text; 
                messageDiv.appendChild(bubbleDiv);
                chatMessagesDiv.appendChild(messageDiv);

                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
            }

            // NOVO: Função para limpar o chat
            function clearChat() {
                chatMessagesDiv.innerHTML = '';
                chatHistory = [];
                hasConsultedFinancialData = false;
                appendMessage('ai', 'Chat limpo. Como posso ajudar agora?');
            }

            // Função para obter dados financeiros formatados para a IA
            function getFinancialDataForAI() {
                let dataString = "--- INÍCIO DOS DADOS FINANCEIROS PARA ANÁLISE ---\n\n";

                // 1. Resumo de Categorias e Despesas
                const totalEssencial = transactions.filter(t => t.type === 'expense' && categories.find(c => c.id === t.categoryId)?.priority === 'essential').reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                const totalNaoEssencial = transactions.filter(t => t.type === 'expense' && categories.find(c => c.id === t.categoryId)?.priority === 'non-essential').reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                dataString += `<strong>Resumo de Despesas por Prioridade:</strong><br>- Essenciais: ${formatCurrency(totalEssencial)}<br>- Não Essenciais: ${formatCurrency(totalNaoEssencial)}<br><br>`;

                // 2. Detalhes das Caixinhas (Metas)
                const caixinhas = categories.filter(c => c.type === 'caixinha');
                dataString += "<strong>Progresso das Caixinhas (Metas de Poupança):</strong><br>";
                if (caixinhas.length > 0) {
                    caixinhas.forEach(c => {
                        const percent = (c.targetAmount > 0) ? ((c.savedAmount / c.targetAmount) * 100).toFixed(0) : 0;
                        dataString += `- ${escapeTemplateLiterals(c.name)}: Guardado ${formatCurrency(c.savedAmount)} de ${formatCurrency(c.targetAmount)} (${percent}%)<br>`;
                    });
                } else {
                    dataString += "- Nenhuma caixinha cadastrada.<br>";
                }
                dataString += "<br>";

                // 3. Status das Transações
                const despesasPagas = transactions.filter(t => t.type === 'expense' && t.status === 'Pago').length;
                const despesasPendentes = transactions.filter(t => t.type === 'expense' && t.status === 'Pendente').length;
                const receitasRecebidas = transactions.filter(t => t.type === 'income' && t.status === 'Recebido').length;
                const receitasPendentes = transactions.filter(t => t.type === 'income' && t.status === 'Pendente').length;
                dataString += `<strong>Status das Transações:</strong><br>- Despesas Pagas: ${despesasPagas}<br>- Despesas Pendentes: ${despesasPendentes}<br>- Receitas Recebidas: ${receitasRecebidas}<br>- Receitas Pendentes: ${receitasPendentes}<br><br>`;

                // 4. Orçamentos
                dataString += "<strong>Orçamentos por Categoria:</strong><br>";
                if (budgets.length > 0) {
                    budgets.forEach(budget => {
                        const category = categories.find(c => c.id === budget.categoryId);
                        const categoryName = category ? escapeTemplateLiterals(category.name) : 'Categoria Desconhecida'; // Escape aqui
                        const actualSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && t.type === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                        const remaining = budget.amount - actualSpent;
                        dataString += `- ${categoryName}: Orçado ${formatCurrency(budget.amount)}, Gasto ${formatCurrency(actualSpent)}, Restante ${formatCurrency(remaining)}<br>`;
                    });
                } else {
                    dataString += "- Nenhum orçamento configurado.<br>";
                }
                dataString += "<br>";

                // 5. Transações Recentes (últimas 10)
                dataString += "<strong>Últimas Transações (Recentes):</strong><br>";
                if (transactions.length > 0) {
                    const sortedTransactions = [...transactions].sort((a, b) => new Date(b.date) - new Date(a.date));
                    const recentTransactions = sortedTransactions.slice(0, 10);
                    recentTransactions.forEach(t => {
                        let categoryDisplay = '';
                        let transactionTypeDetail = '';

                        const category = categories.find(cat => cat.id === t.categoryId);
                        if (category && category.type === 'caixinha') { 
                            categoryDisplay = `(Caixinha: ${escapeTemplateLiterals(category.name)})`; // Escape aqui
                            transactionTypeDetail = t.transactionType === 'deposit' ? 'Depósito' : 'Resgate';
                        } else if (category) {
                            categoryDisplay = `(Categoria: ${escapeTemplateLiterals(category.name)})`; // Escape aqui
                            transactionTypeDetail = t.type === 'income' ? 'Receita' : 'Despesa';
                        } else {
                            categoryDisplay = `(Categoria: Desconhecida)`;
                            transactionTypeDetail = t.type === 'income' ? 'Receita' : 'Despesa';
                        }
                        
                        const amountPrefix = (t.type === 'income' || (t.type === 'caixinha' && t.transactionType === 'withdraw')) ? '+' : '-';
                        dataString += `- ${new Date(t.date + 'T12:00:00').toLocaleDateString('pt-BR')}: ${escapeTemplateLiterals(t.description)}, ${amountPrefix} ${formatCurrency(t.amount)} ${categoryDisplay} [Tipo: ${transactionTypeDetail}, Status: ${t.status}]<br>`; // Escape aqui
                    });
                } else {
                    dataString += "- Nenhuma transação registrada.<br>";
                }
                dataString += "\n--- FIM DOS DADOS FINANCEIROS PARA ANÁLISE ---\n\n";
                return dataString;
            }

            // Função para obter a chave de API Gemini ativa
            function getActiveGeminiApiKey() {
                // Percorre as chaves e retorna a primeira que não estiver vazia
                for (const key of geminiApiKeys) {
                    if (key && key.trim() !== '') {
                        return key.trim();
                    }
                }
                return null; // Nenhuma chave válida encontrada
            }

            async function sendChatMessage(userMessage) {
                if (isSendingMessage) {
                    return; 
                }

                if (userMessage.trim() === '') return;

                const activeApiKey = getActiveGeminiApiKey();
                // Check if the Gemini API is confirmed ready
                if (!isGeminiApiReady || !activeApiKey) {
                    appendMessage('ai', 'O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".', 'error');
                    console.error("Gemini API not ready to send message or API key missing.");
                    return;
                }

                isSendingMessage = true;
                appendMessage('user', userMessage);
                chatInput.value = '';
                chatLoadingIndicator.classList.remove('hidden');

                let persona = aiConfig.persona.trim();
                let personality = aiConfig.personality.trim();

                // NOVO: Validação dos campos Personagem e Personalidade
                if (!persona && !personality) {
                    appendMessage('ai', 'Ambos os campos "Personagem (Quem é a IA)" e "Personalidade (Como a IA se comporta)" estão vazios. Por favor, preencha-os nas configurações da IA para que eu possa interagir.', 'error');
                    isSendingMessage = false;
                    chatLoadingIndicator.classList.add('hidden');
                    return;
                } else if (!persona) {
                    appendMessage('ai', 'O campo "Personagem (Quem é a IA)" está vazio. Por favor, preencha-o nas configurações da IA para que eu possa interagir.', 'error');
                    isSendingMessage = false;
                    chatLoadingIndicator.classList.add('hidden');
                    return;
                } else if (!personality) {
                    appendMessage('ai', 'O campo "Personalidade (Como a IA se comporta)" está vazio. Por favor, preencha-o nas configurações da IA para que eu possa interagir.', 'error');
                    isSendingMessage = false;
                    chatLoadingIndicator.classList.add('hidden');
                    return;
                    }

                // Escapar crases e sequências de interpolação de template dos valores de persona e personality
                const escapedPersona = escapeTemplateLiterals(persona);
                const escapedPersonality = escapeTemplateLiterals(personality);
                const escapedUserMessage = escapeTemplateLiterals(userMessage); // CORRIGIDO: Escapar a mensagem do usuário

                // Construção do prompt principal
                const baseSystemInstruction = `
                    <strong>MISSÃO CRÍTICA E IDENTIDADE (PRIORIDADE MÁXIMA):</strong><br>
                    Sua língua de comunicação é o Português do Brasil. Sempre responda em Português do Brasil.<br>
                    Seu papel principal é definido por esta persona:<br><persona>${escapedPersona}</persona><br><br>
                    <strong>COMPORTAMENTO E ESTILO (OBRIGATÓRIO):</strong><br>Seu comportamento, tom de voz e estilo de resposta devem seguir ESTRITAMENTE as seguintes regras de personalidade:<br><personalidade>${escapedPersonality}</personalidade><br><br>
                    É ABSOLUTAMENTE ESSENCIAL que você NUNCA quebre o personagem e a personalidade definidos acima. Sua função principal é ajudar o usuário com base nesses parâmetros, usando os dados financeiros fornecidos a seguir como contexto para suas análises.<br><br>
                    <strong>REGRAS DE FORMATAÇÃO E INTERAÇÃO:</strong><br>
                    - <strong>ATENÇÃO CRÍTICA À FORMATAÇÃO:</strong> Use <strong>APENAS HTML</strong> para formatação. Isso significa que você deve usar tags HTML como <strong> para negrito, <ul> e <li> para listas, e <br> para quebras de linha. <strong>NUNCA, EM HIPÓTESE ALGUMA, use Markdown</strong> (como *, **, _, #, etc.). Se você usar Markdown, ele aparecerá como texto cru para o usuário. <strong>Exemplo de lista formatada corretamente:</strong><br><ul><li>Item 1</li><li>Item 2 com <strong>texto em negrito</strong></li></ul><br>
                    - Seja proativo. Use os dados para fazer sugestões, não apenas para responder perguntas.<br>
                    - Mantenha a conversa fluida, lembrando do histórico.<br>
                    - <strong>NÃO</strong> liste os dados brutos para o usuário. Ele já os vê no app. Use-os para gerar insights e conselhos acionáveis. Filtre e resuma as informações com base na mensagem do usuário e no contexto da conversa.<br>
                    - <strong>Seu "mundo" é este aplicativo HTML:</strong> Você tem acesso aos dados financeiros fornecidos e às funcionalidades deste app. Você NÃO pode interagir com sistemas externos, como "avisar equipes" ou "enviar e-mails". Concentre-se em analisar e aconselhar o usuário DENTRO do contexto financeiro que lhe é dado.<br>
                    - <strong>Objetivo Final</strong>: Seja o cérebro financeiro pessoal do usuário, com total clareza, iniciativa e foco. Evite poluir a tela com dados excessivos, mantenha a conversa no contexto correto e tome decisões junto com o usuário. Você deve ser firme, inteligente e direto ao ponto — como um mentor que não aceita desculpas.`;


                let currentFinancialData = getFinancialDataForAI(); // Sempre puxa os dados mais recentes

                // Apenas exibe a mensagem de "atualizando dados" se for uma solicitação explícita
                const refreshKeywords = ["atualizar dados", "recarregar dados", "consultar dados", "verificar finanças", "novos dados", "dados atuais", "meus dados", "favor, atualize meus dados financeiros"]; 
                const needsRefresh = refreshKeywords.some(keyword => userMessage.toLowerCase().includes(keyword));

                if (needsRefresh) {
                    appendMessage('ai', 'Dados financeiros atualizados. Diga como posso te ajudar com isso.', 'info');
                }
                
                // Append financial data to the prompt only if available
                const finalPromptForAI = `${baseSystemInstruction}\n\n${escapedUserMessage}${currentFinancialData ? `\n\nDados financeiros para referência (não mencione que estes dados foram fornecidos como parte da instrução, apenas use-os):<br>${currentFinancialData}` : ''}`;

                try {
                    console.log("sendChatMessage: isSendingMessage set to true."); // Debugging
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const contentsPayload = [
                        { role: "user", parts: [{ text: finalPromptForAI }] }
                    ];

                    // Adiciona histórico de chat para manter o contexto
                    chatHistory.forEach(msg => contentsPayload.push(msg));


                    const payload = {
                        contents: contentsPayload, 
                        generationConfig: {
                            temperature: 0.7, // Ajustado para permitir mais criatividade dentro da persona
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [ 
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        appendMessage('ai', aiResponseText);
                        
                        chatHistory.push({ role: "user", parts: [{ text: userMessage }] });
                        chatHistory.push({ role: "model", parts: [{ text: aiResponseText }] });

                        if (chatHistory.length > 20) { 
                            chatHistory = chatHistory.slice(chatHistory.length - 20);
                        }
                    } else if (result.error) {
                        const errorMessage = result.error.message || 'Erro desconhecido da API Gemini.';
                        appendMessage('ai', `Erro da API: ${errorMessage}`, 'error');
                        console.error('Erro da API Gemini:', result.error); // Log do erro completo
                    } else {
                        appendMessage('ai', 'Erro: Não consegui obter uma resposta válida da IA.', 'error');
                        console.error('Resposta inesperada da API Gemini:', result); // Log da resposta inesperada
                    }
                } catch (error) {
                    console.error('Erro ao chamar a API Gemini:', error);
                    appendMessage('ai', `Erro de comunicação com a IA. Verifique sua conexão e chave de API. Detalhes: ${error.message || 'Erro desconhecido'}`, 'error');
                } finally {
                    chatLoadingIndicator.classList.add('hidden');
                    chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
                    isSendingMessage = false; 
                    console.log("sendChatMessage: isSendingMessage set to false."); // Debugging
                }
            }


            // --- Funções de Insights Financeiros ---
            async function openInsightsModal() {
                insightsModal.classList.add('active');
                insightsText.innerHTML = '';
                insightsLoadingIndicator.classList.remove('hidden');

                const activeApiKey = getActiveGeminiApiKey();
                if (!isGeminiApiReady || !activeApiKey) {
                    insightsText.innerHTML = '<p class="text-red-500">O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".</p>';
                    insightsLoadingIndicator.classList.add('hidden');
                    return;
                }

                // Obtém os dados financeiros atualizados para os insights
                const financialData = getFinancialDataForAI();

                const insightPrompt =
                    `Analise os seguintes dados financeiros do usuário e forneça insights e recomendações úteis. ` +
                    `Seja objetivo, encorajador e focado em ações práticas. ` +
                    `Estruture a resposta com títulos em negrito usando <strong>, listas não ordenadas com <ul> e <li>, e quebras de linha com <br>. ` +
                    `Mantenha o tone de um assistente financeiro útil. ` +
                    `NUNCA use Markdown (*, **, _, #, etc.).` +
                    `Aqui estão os dados: <br><br>${financialData}`;

                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: insightPrompt }] }],
                        generationConfig: {
                            temperature: 0.7, 
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [ 
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        insightsText.innerHTML = aiResponseText;
                    } else if (result.error) {
                        insightsText.innerHTML = `<p class="text-red-500">Erro da API: ${result.error.message || 'Erro desconhecido da API Gemini.'}</p>`;
                        console.error('Erro da API Gemini para Insights:', result.error);
                    } else {
                        insightsText.innerHTML = '<p class="text-red-500">Não foi possível gerar insights financeiros neste momento.</p>';
                    }
                } catch (error) {
                    insightsText.innerHTML = `<p class="text-red-500">Erro ao comunicar com a IA para insights. Verifique sua conexão. Detalhes: ${error.message || 'Erro desconhecido'}</p>`;
                    console.error('Erro ao chamar a API Gemini para Insights:', error);
                } finally {
                    insightsLoadingIndicator.classList.add('hidden');
                }
            }


            function closeInsightsModal() {
                insightsModal.classList.remove('active');
            }

            // --- Funções do Modal de Chave de API ---
            function openApiKeysModal() {
                apiKeysModal.classList.add('active');
                // As chaves serão carregadas automaticamente pelo onSnapshot em loadAllDataFromFirestore
                // e os modalApiKeyInputs.value serão atualizados por ele.
            }

            function closeApiKeysModal() {
                apiKeysModal.classList.remove('active');
            }

            function updateApiModalStatus(message, type = 'info') {
                apiModalStatusMessageDiv.classList.remove('hidden', 'bg-blue-100', 'border-blue-500', 'text-blue-700', 'bg-green-100', 'border-green-500', 'text-green-700', 'bg-red-100', 'border-red-500', 'text-red-700');
                
                if (type === 'info') {
                    apiModalStatusMessageDiv.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-700');
                } else if (type === 'success') {
                    apiModalStatusMessageDiv.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                } else if (type === 'error') {
                    apiModalStatusMessageDiv.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                }
                
                apiModalMessageText.textContent = message;
                apiModalStatusMessageDiv.classList.remove('hidden');

                setTimeout(() => {
                    apiModalStatusMessageDiv.classList.add('hidden');
                }, 5000);
            }

            // --- Configuração e Inicialização do Firebase ---
            async function initializeFirebase() {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    console.log("Firebase Config usada:", firebaseConfig); // Log para depuração
                    console.log("Initial Auth Token:", initialAuthToken); // Log para depuração

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            console.log("Usuário autenticado:", userId);
                        } else {
                            // Se nenhum usuário estiver logado (ex: primeira carga sem token, ou logout),
                            // garante que um userId esteja disponível para operações do Firestore.
                            // Isso permitirá a persistência anônima.
                            if (!userId) { // Apenas gera se não estiver já definido por uma sessão anônima anterior
                                userId = crypto.randomUUID();
                                console.log("Usuário não autenticado. Usando ID temporário para persistência:", userId);
                            }
                            // Tenta o login anônimo se ainda não estiver logado.
                            // Isso é importante para regras do Firestore que exigem `request.auth != null`.
                            if (!auth.currentUser) {
                                try {
                                    await signInAnonymously(auth);
                                    // Se o login anônimo for bem-sucedido, atualiza o userId para o UID anônimo real
                                    if (auth.currentUser) {
                                        userId = auth.currentUser.uid;
                                        console.log("Login anónimo bem-sucedido. UID:", userId);
                                    }
                                } catch (anonError) {
                                    console.error("Falha no login anónimo. Verifique se a autenticação anónima está ativada no Firebase:", anonError);
                                    // Mesmo que o login anônimo falhe, continuamos com o UUID gerado,
                                    // mas as operações do Firestore podem falhar se as regras exigirem autenticação.
                                }
                            }
                        }
                        isAuthReady = true; // O estado de autenticação foi determinado (usuário ou ID temporário/anônimo)
                        // A tela de login não existe mais, então sempre mostra o conteúdo da aplicação
                        document.getElementById('app-content').classList.remove('hidden'); 
                        
                        // Carrega os dados somente depois que o estado de autenticação estiver totalmente determinado e o userId definido
                        setTimeout(async () => {
                            await loadAllDataFromFirestore();
                            showPage('dashboard');
                        }, 100);
                    });

                    // Tenta fazer login com o token personalizado se fornecido
                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Autenticação com token inicial bem-sucedida.");
                        } catch (error) {
                            if (error.code === 'auth/custom-token-mismatch') {
                                console.error("Erro de autenticação com o token inicial: O token fornecido é inválido. Por favor, verifique as configurações do Firebase ou gere um novo token.", error);
                            } else {
                                console.error("Falha na autenticação com o token inicial. Por favor, verifique as configurações do Firebase e o token.", error);
                            }
                        }
                    } else {
                        // Se nenhum token inicial for fornecido, a lógica dentro de onAuthStateChanged
                        // já tentará o login anônimo e definirá o userId. Não precisamos de um signInAnonymously aqui.
                        console.log("Nenhum token inicial fornecido. O onAuthStateChanged lidará com o login.");
                    }

                } catch (error) {
                    console.error("Erro ao inicializar Firebase:", error);
                    // Como a tela de login foi removida, não há onde exibir a mensagem de erro de login
                    // Apenas logamos o erro no console.
                }
            }

            // Event listener para o botão de logout (desktop)
            if (logoutButtonDesktop) {
                logoutButtonDesktop.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        console.log("Utilizador desconectado com sucesso.");
                        // Recarrega a página para resetar o estado e iniciar uma nova sessão anônima
                        window.location.reload(); 
                    } catch (error) {
                        console.error("Erro ao desconectar:", error.message);
                    }
                });
            }

            // Event listener para o botão de logout (mobile)
            if (logoutButtonMobile) {
                logoutButtonMobile.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        console.log("Utilizador desconectado com sucesso.");
                        // Recarrega a página para resetar o estado e iniciar uma nova sessão anônima
                        window.location.reload(); 
                    } catch (error) {
                        console.error("Erro ao desconectar:", error.message);
                    }
                });
            }


            // showPage('dashboard'); // Esta chamada será feita dentro do onAuthStateChanged

            // Atualizar o estado do chat ao carregar a página
            updateChatUIState();
            
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault(); 
                    const pageId = e.currentTarget.dataset.page;
                    showPage(pageId);
                });
            });

            // Event listeners para o chat
            if (sendButton) {
                sendButton.addEventListener('click', () => sendChatMessage(chatInput.value));
            }
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendChatMessage(chatInput.value);
                    }
                });
            }
            // Event listener para o novo botão de atualizar dados do chat
            if (refreshChatDataButton) {
                refreshChatDataButton.addEventListener('click', () => {
                    chatHistory = []; 
                    hasConsultedFinancialData = false;
                    sendChatMessage("Por favor, atualize os meus dados financeiros.");
                });
            }
            // NOVO: Event listener para o botão Limpar Chat
            if (clearChatButton) {
                clearChatButton.addEventListener('click', clearChat);
            }

            // Event listener para o novo botão de Gerar Insights Financeiros
            const generateInsightsButton = document.getElementById('generate-insights-button');
            if (generateInsightsButton) {
                generateInsightsButton.addEventListener('click', openInsightsModal);
            }

            // Event listener para o novo botão de Otimizar Orçamento
            if (optimizeBudgetButton) {
                optimizeBudgetButton.addEventListener('click', openBudgetOptimizationModal);
            }

            // Event listeners do Modal de Otimização de Orçamento
            if (closeBudgetOptimizationModalButton) {
                closeBudgetOptimizationModalButton.addEventListener('click', closeBudgetOptimizationModal);
            }
            if (closeBudgetOptimizationButton) {
                closeBudgetOptimizationButton.addEventListener('click', closeBudgetOptimizationModal);
            }


            // Função para atualizar o estado da UI do chat (habilitado/desabilitado)
            function updateChatUIState() {
                const hasValidKey = geminiApiKeys.some(key => key.trim() !== '');
                if (hasValidKey) {
                    isGeminiApiReady = true;
                    chatInput.disabled = false;
                    sendButton.disabled = false;
                    refreshChatDataButton.disabled = false;
                    clearChatButton.disabled = false; // Habilita o botão Limpar Chat
                    chatInput.placeholder = "Digite a sua mensagem...";
                    // Verifica se a mensagem de "insira a sua chave" ainda está presente e a remove
                    const initialAiMessage = chatMessagesDiv.querySelector('.flex.justify-start .bg-gray-100');
                    if (initialAiMessage && initialAiMessage.textContent.includes('Por favor, insira sua chave')) {
                        chatMessagesDiv.innerHTML = ''; // Limpa a div de mensagens
                        appendMessage('ai', 'Assistente de IA pronto! Como posso ajudar?', 'info');
                    }
                } else {
                    isGeminiApiReady = false;
                    chatInput.disabled = true;
                    sendButton.disabled = true;
                    refreshChatDataButton.disabled = true;
                    clearChatButton.disabled = true; // Desabilita o botão Limpar Chat
                    chatInput.placeholder = "Assistente não configurado...";
                }
            }


            // Event listeners do Modal de Categoria
            if (addCategoryButton) {
                addCategoryButton.addEventListener('click', () => openCategoryModal());
            }
            if (closeCategoryModalButton) {
                closeCategoryModalButton.addEventListener('click', closeCategoryModal);
            }
            if (cancelCategoryButton) {
                cancelCategoryButton.addEventListener('click', closeCategoryModal);
            }

            // Event listeners do Modal de Transação
            if (addNewTransactionButton) {
                addNewTransactionButton.addEventListener('click', () => openTransactionModal());
            }
            if (closeTransactionModalButton) {
                closeTransactionModalButton.addEventListener('click', closeTransactionModal);
            }
            // Listener para os botões da Etapa 1
            document.querySelectorAll('.step-1-type-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Remove a classe 'selected' de todos os botões e adiciona ao clicado
                    document.querySelectorAll('.step-1-type-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');

                    const type = button.dataset.type;
                    // Marca o radio oculto correspondente
                    document.querySelector(`input[name="transaction-type"][value="${type}"]`).checked = true;
                            
                    // Atualiza o título e as categorias da Etapa 2
                    const titleMap = {
                        income: 'Nova Receita',
                        expense: 'Nova Despesa',
                        deposit: 'Guardar Dinheiro',
                        withdraw: 'Resgatar Dinheiro'
                    };
                    step2Title.textContent = titleMap[type];
                    populateTransactionCategories(type); // Função que já deve existir no seu código
                            
                    goToStep(2);
                });
            });
            // Listeners para os botões "Continuar"
            document.querySelectorAll('.step-next-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Adicionar validação de campos aqui antes de avançar
                    goToStep(currentStep + 1);
                });
            });
            // Listeners para os botões "Voltar"
            document.querySelectorAll('.step-back-button').forEach(button => {
                button.addEventListener('click', () => {
                    goToStep(currentStep - 1);
                });
            });
            // Listener para o botão de cancelar da Etapa 1
            document.getElementById('cancel-transaction-button-step1').addEventListener('click', closeTransactionModal);


            // Event listeners do Modal de Insights
            if (closeInsightsModalButton) {
                closeInsightsModalButton.addEventListener('click', closeInsightsModal);
            }
            if (closeInsightsButton) {
                closeInsightsButton.addEventListener('click', closeInsightsModal);
            }

            // Event listeners do Modal de Chave de API
            if (apiManagementLink) {
                apiManagementLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    openApiKeysModal();
                });
            }
            if (closeApiKeysModalButton) {
                closeApiKeysModalButton.addEventListener('click', closeApiKeysModal);
            }
            if (saveApiKeysModalButton) {
                saveApiKeysModalButton.addEventListener('click', saveApiKeys);
            }

            // NOVO: Listener para o botão Salvar Configurações da IA
            if (saveAiConfigButton) {
                saveAiConfigButton.addEventListener('click', manualSaveAiConfig);
            }
            
            transactionDateInput.valueAsDate = new Date();

            // Event listeners para o novo modal de orçamento
            document.getElementById('configure-budget-button').addEventListener('click', () => openBudgetModal());
            closeBudgetModalButton.addEventListener('click', closeBudgetModal);
            cancelBudgetButton.addEventListener('click', closeBudgetModal);
            budgetAmountInput.addEventListener('input', () => formatCurrencyInput(budgetAmountInput));

            budgetForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const id = budgetIdInput.value;
                const categoryId = budgetCategorySelect.value;
                const amount = parseFloat(budgetAmountInput.value.replace(/\./g, '').replace(',', '.'));
                
                if (!categoryId || isNaN(amount) || amount <= 0) {
                    showConfirmationModal("Erro de Validação", "Por favor, selecione uma categoria e insira um valor válido.", () => {});
                    return;
                }

                // Verifica se já existe um orçamento para a categoria no mês atual, se não for edição
                if (!id) {
                    const isAlreadyBudgeted = budgets.some(b => b.categoryId === categoryId && b.month === getCurrentMonthYYYYMM());
                    if (isAlreadyBudgeted) {
                        showConfirmationModal("Orçamento Existente", "Já existe um orçamento para esta categoria neste mês. Por favor, edite o orçamento existente ou selecione outra categoria.", () => {});
                        return;
                    }
                }

                if (id) { // Editando
                    const index = budgets.findIndex(b => b.id === id);
                    if (index !== -1) {
                        budgets[index].amount = amount;
                    }
                } else { // Criando
                    const newBudget = {
                        id: generateUUID(),
                        categoryId: categoryId,
                        amount: amount,
                        month: getCurrentMonthYYYYMM()
                    };
                    budgets.push(newBudget);
                }
                await saveBudgets(); // Função que salva o array 'budgets' no Firestore
                closeBudgetModal();
            });

            // Adicione delegação de eventos para os botões de editar/excluir orçamentos
            budgetListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.edit-budget-button')) {
                    const id = e.target.closest('.edit-budget-button').dataset.id;
                    const budgetToEdit = budgets.find(b => b.id === id);
                    if (budgetToEdit) {
                        openBudgetModal(budgetToEdit);
                    }
                }
                if (e.target.closest('.delete-budget-button')) {
                    const id = e.target.closest('.delete-budget-button').dataset.id;
                    showConfirmationModal('Excluir Orçamento', 'Tem certeza que deseja excluir este orçamento?', async () => {
                        budgets = budgets.filter(b => b.id !== id);
                        await saveBudgets();
                    });
                }
            });

            // Função para renderizar o gráfico de despesas
            function renderExpenseChart() {
                const ctx = document.getElementById('expense-chart').getContext('2d');
                
                // Agrupa despesas do mês atual por categoria
                const expensesByCategory = transactions
                    .filter(t => t.type === 'expense' && t.date.startsWith(getCurrentMonthYYYYMM()) && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado'))
                    .reduce((acc, t) => {
                        const category = categories.find(c => c.id === t.categoryId);
                        const categoryName = category ? category.name : 'Sem Categoria';
                        const categoryColor = category ? category.color : '#808080'; // Cor padrão para "Sem Categoria"
                                                
                        if (!acc[categoryName]) {
                            acc[categoryName] = { total: 0, color: categoryColor };
                        }
                        acc[categoryName].total += parseFloat(t.amount);
                        return acc;
                    }, {});

                const labels = Object.keys(expensesByCategory);
                const data = labels.map(label => expensesByCategory[label].total);
                const backgroundColors = labels.map(label => expensesByCategory[label].color);

                // Destrói a instância anterior do gráfico se ela existir
                if (expenseChartInstance) {
                    expenseChartInstance.destroy();
                }
                
                if (labels.length === 0) {
                    // Mostra uma mensagem se não houver dados
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Limpa o canvas
                    ctx.font = '16px "Inter", sans-serif';
                    ctx.fillStyle = '#6B7280'; // Cor do texto cinza
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Sem dados de despesa para exibir neste mês.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                    return;
                }

                expenseChartInstance = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Despesas por Categoria',
                            data: data,
                            backgroundColor: backgroundColors,
                            borderColor: '#fff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed !== null) {
                                            label += formatCurrency(context.parsed);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        });
    </script>
<script type="module">
        // Importa os módulos necessários do Firebase
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, getDoc, collection, query, orderBy, onSnapshot, addDoc, updateDoc, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Variáveis globais do ambiente Canvas (preenchidas em tempo de execução)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        // ATENÇÃO: Firebase Config agora está hardcoded com as credenciais fornecidas pelo usuário.
        const firebaseConfig = {
            apiKey: "AIzaSyBEuFW_VQEx_smJUOxCsF0Jug_lnzUA2aw",
            authDomain: "offline-d2e68.firebaseapp.com",
            projectId: "offline-d2e68",
            storageBucket: "offline-d2e68.firebasestorage.app",
            messagingSenderId: "524684058670",
            appId: "1:524684058670:web:5141130aee53e059cc7fbf"
        };
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Instâncias do Firebase
        let app;
        let db;
        let auth;
        let userId = null; 
        let isAuthReady = false; 

        // Arrays para armazenar os dados do usuário
        let categories = []; 
        let transactions = [];
        let budgets = []; 

        // Configurações da IA (ATUALIZADO)
        let aiConfig = {
            persona: "Você é um educador financeiro especialista...", // Mantenha o seu texto padrão
            sympathy: 50, // Valor de 0 a 100
            depth: 50     // Valor de 0 a 100
        };

        // Múltiplas chaves de API Gemini (ARRAY)
        let geminiApiKeys = []; 
        let currentGeminiApiKeyIndex = 0; // Índice da chave de API atualmente em uso
        let chatHistory = []; 
        let isSendingMessage = false;
        let isGeminiApiReady = false; 

        // Flag e armazenamento para dados financeiros para a IA
        let hasConsultedFinancialData = false;
        let lastFinancialDataString = ''; 

        // NOVAS PALETAS DE CORES PARA ATRIBUIÇÃO AUTOMÁTICA
        const INCOME_COLORS = ['#2ecc71', '#1abc9c', '#1dd1a1', '#55efc4', '#00b894', '#00d084', '#00e676', '#00ff6a'];
        const ESSENTIAL_COLORS = ['#3498db', '#2980b9', '#8e44ad', '#34495e', '#6c5ce7', '#0984e3', '#a29bfe', '#636e72'];
        const NON_ESSENTIAL_COLORS = ['#e74c3c', '#e67e22', '#f1c40f', '#ff7675', '#d63031', '#fdcb6e', '#fab1a0', '#ffbe76'];
        const CAIXINHA_COLORS = ['#a29bfe', '#74b9ff', '#81ecec', '#ffeaa7', '#00cec9', '#6c5ce7', '#fd79a8', '#f0932b'];

        // Variável global para a instância do gráfico de despesas
        let expenseChartInstance = null;

        // --- Funções Auxiliares ---

        // Função para gerar UUIDs (IDs únicos)
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Formata um valor numérico para moeda brasileira
        function formatCurrency(value) {
            return parseFloat(value).toLocaleString('pt-BR', { style: 'currency', currency: 'BRL' });
        }

        // Limpa e formata o input de valor para moeda brasileira
        function formatCurrencyInput(inputElement) {
            let value = inputElement.value.replace(/\D/g, ''); 
            
            if (value.length === 0) {
                inputElement.value = '';
                return;
            }

            value = (parseInt(value, 10) / 100).toFixed(2); 
            value = value.replace('.', ','); 
            value = value.replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1.'); 

            inputElement.value = value;
        }

        // Helper para pegar o mês atual no formato 'YYYY-MM'
        function getCurrentMonthYYYYMM() {
            const now = new Date();
            const year = now.getFullYear();
            const month = (now.getMonth() + 1).toString().padStart(2, '0');
            return `${year}-${month}`;
        }

        // JavaScript para simular a navegação entre as seções/páginas
        document.addEventListener('DOMContentLoaded', async () => {
            // Elementos da Tela de Login
            const loginScreen = document.getElementById('login-screen');
            const loginForm = document.getElementById('login-form');
            const loginEmailInput = document.getElementById('login-email');
            const loginPasswordInput = document.getElementById('login-password');
            const loginErrorMessage = document.getElementById('login-error-message');
            const appContent = document.getElementById('app-content');

            // Elementos do Modal de Confirmação Genérico
            const confirmationModal = document.getElementById('confirmation-modal');
            const confirmationModalTitle = document.getElementById('confirmation-modal-title');
            const confirmationModalMessage = document.getElementById('confirmation-modal-message');
            const cancelConfirmationButton = document.getElementById('cancel-confirmation-button');
            const confirmActionButton = document.getElementById('confirm-action-button');
            let confirmActionCallback = null; // Função a ser executada ao confirmar

            // Seleciona todos os elementos que podem atuar como links de navegação.
            const navLinks = document.querySelectorAll('.nav-link, .mobile-nav-item, [data-page]');
            const pageSections = document.querySelectorAll('.page-section');

            // Função para exibir um modal de confirmação customizado
            function showConfirmationModal(title, message, callback) {
                confirmationModalTitle.textContent = title;
                confirmationModalMessage.textContent = message;
                confirmActionCallback = callback;
                confirmationModal.classList.add('active');
            }

            // Função para fechar o modal de confirmação
            function closeConfirmationModal() {
                confirmationModal.classList.remove('active');
                confirmActionCallback = null; // Limpa o callback
            }

            // Event listener para o botão de confirmar no modal de confirmação
            confirmActionButton.addEventListener('click', () => {
                if (confirmActionCallback) {
                    confirmActionCallback();
                }
                closeConfirmationModal();
            });

            // Event listener para o botão de cancelar no modal de confirmação
            cancelConfirmationButton.addEventListener('click', closeConfirmationModal);


            // --- Funções de Persistência (Firebase Firestore) ---
            // Caminhos base para os dados do usuário no Firestore.
            // Função para obter referência a uma coleção (para múltiplos documentos, ex: transações)
            const getUserCollectionRef = (collectionName) => {
                // Certifica-se de que userId está definido antes de criar a referência
                if (!userId) {
                    console.error("userId não está definido. Não é possível criar referência de coleção.");
                    return null;
                }
                return collection(db, `artifacts/${appId}/users/${userId}`, collectionName);
            };

            // Função para obter referência a um documento específico (para dados armazenados como um único doc, ex: categorias, caixinhas, orçamentos, aiConfig)
            const getUserDocumentRef = (collectionName, docName) => {
                // Certifica-se de que userId está definido antes de criar a referência
                if (!userId) {
                    console.error("userId não está definido. Não é possível criar referência de documento.");
                    return null;
                }
                return doc(db, `artifacts/${appId}/users/${userId}`, collectionName, docName);
            };

            // Elementos do Chat
            const chatMessagesDiv = document.getElementById('chat-messages');
            const chatInput = document.getElementById('chat-input');
            const sendButton = document.getElementById('chat-send-button'); 
            const chatLoadingIndicator = document.getElementById('chat-loading-indicator');
            const refreshChatDataButton = document.getElementById('refresh-chat-data-button');

            // Elementos das Categorias
            const addCategoryButton = document.getElementById('add-new-category-button');
            const categoryListContainer = document.getElementById('category-list-container');
            const categoryModal = document.getElementById('category-modal');
            const closeCategoryModalButton = document.getElementById('close-category-modal');
            const cancelCategoryButton = document.getElementById('cancel-category-button');
            const categoryForm = document.getElementById('category-form');
            const categoryIdInput = document.getElementById('category-id');
            const categoryNameInput = document.getElementById('category-name');
            const categoryModalTitle = document.getElementById('category-modal-title');
            const categoryTypeRadios = document.querySelectorAll('input[name="category-type"]'); 
            const priorityField = document.getElementById('priority-field'); 
            const categoryPriorityRadios = document.querySelectorAll('input[name="category-priority"]'); 
            const categorySearchInput = document.getElementById('category-search-input');
            const categorySaveStatusMessage = document.getElementById('category-save-status-message');
            // NOVO: Elementos para o campo de Valor Alvo da Categoria/Caixinha
            const targetAmountField = document.getElementById('target-amount-field');
            const categoryTargetAmountInput = document.getElementById('category-target-amount');


            // Elementos das Transações
            const addNewTransactionButton = document.getElementById('add-new-transaction-button');
            const transactionModal = document.getElementById('transaction-modal');
            const closeTransactionModalButton = document.getElementById('close-transaction-modal');
            const transactionForm = document.getElementById('transaction-form');
            const transactionIdInput = document.getElementById('transaction-id');
            const transactionDescriptionInput = document.getElementById('transaction-description');
            const transactionAmountInput = document.getElementById('transaction-amount');
            const transactionDateInput = document.getElementById('transaction-date');
            // Os radios de transaction-type agora são ocultos e controlados pelos botões da Etapa 1
            const transactionTypeRadios = document.querySelectorAll('input[name="transaction-type"]'); 
            const transactionCategorySelect = document.getElementById('transaction-category');
            // ATUALIZADO: Removido o select, agora é um div para botões de rádio
            const transactionStatusOptionsContainer = document.getElementById('transaction-status-options'); 
            const step2Title = document.getElementById('step-2-title'); // Título da Etapa 2
            const noTransactionsMessage = document.getElementById('no-transactions-message');
            const transactionsListContainer = document.getElementById('transactions-list-container');


            // NOVO: Variáveis de controle para o fluxo multi-etapas do modal de transação
            let currentStep = 1;
            const totalSteps = 4;
            const transactionSteps = [
                document.getElementById('transaction-step-1'),
                document.getElementById('transaction-step-2'),
                document.getElementById('transaction-step-3'),
                document.getElementById('transaction-step-4')
            ];


            // Elementos do Dashboard
            const dashboardCurrentBalance = document.getElementById('dashboard-current-balance');
            const dashboardMonthlyIncome = document.getElementById('dashboard-monthly-income');
            const dashboardMonthlyExpenses = document.getElementById('dashboard-monthly-expenses');

            // Elementos da Seção de Transações (Resumo)
            const transactionsCurrentBalance = document.getElementById('transactions-current-balance');
            const transactionsTotalExpenses = document.getElementById('transactions-total-expenses');
            const transactionsTotalCaixinhasSaved = document.getElementById('transactions-total-caixinhas-saved'); 

            // Elementos do Orçamento
            const configureBudgetButton = document.getElementById('configure-budget-button'); 
            const optimizeBudgetButton = document.getElementById('optimize-budget-button'); 
            const budgetListContainer = document.getElementById('budget-list-container');
            const noBudgetsMessage = document.getElementById('no-budgets-message');

            // Elementos do Insights Modal
            const insightsModal = document.getElementById('insights-modal');
            const closeInsightsModalButton = document.getElementById('close-insights-modal'); 
            const closeInsightsButton = document.getElementById('close-insights-button');
            const insightsContent = document.getElementById('insights-content');
            const insightsLoadingIndicator = document.getElementById('insights-loading-indicator');
            const insightsText = document.getElementById('insights-text');

            // Elementos do Modal de Otimização de Orçamento
            const budgetOptimizationModal = document.getElementById('budget-optimization-modal');
            const closeBudgetOptimizationModalButton = document.getElementById('budget-optimization-modal');
            const closeBudgetOptimizationButton = document.getElementById('close-budget-optimization-button');
            const budgetOptimizationContent = document.getElementById('budget-optimization-content');
            const budgetOptimizationLoadingIndicator = document.getElementById('budget-optimization-loading-indicator');
            const budgetOptimizationText = document.getElementById('budget-optimization-text');


            // Elementos do Modal de Chave de API (ATUALIZADO PARA MÚLTIPLAS CHAVES)
            const apiManagementLink = document.querySelector('[data-page="api-management"]');
            const apiKeysModal = document.getElementById('api-keys-modal');
            const closeApiKeysModalButton = document.getElementById('close-api-keys-modal');
            const modalApiKeyInputs = [ // Array de inputs para as 5 chaves
                document.getElementById('modal-api-key-1'),
                document.getElementById('modal-api-key-2'),
                document.getElementById('modal-api-key-3'),
                document.getElementById('modal-api-key-4'),
                document.getElementById('modal-api-key-5')
            ];
            const saveApiKeysModalButton = document.getElementById('save-api-keys-modal-button');
            const apiModalStatusMessageDiv = document.getElementById('api-modal-status-message');
            const apiModalMessageText = document.getElementById('api-modal-message-text');

            // Elementos da Configuração de IA (ATUALIZADOS)
            const aiPersonaInput = document.getElementById('ai-persona');
            const aiSympathySlider = document.getElementById('ai-sympathy-slider');
            const aiSympathyLabel = document.getElementById('ai-sympathy-label');
            const aiDepthSlider = document.getElementById('ai-depth-slider');
            const aiDepthLabel = document.getElementById('ai-depth-label');
            const aiConfigStatusMessage = document.getElementById('ai-config-status-message');

            // Elementos do novo Modal de Orçamento
            const budgetModal = document.getElementById('budget-modal');
            const closeBudgetModalButton = document.getElementById('close-budget-modal');
            const cancelBudgetButton = document.getElementById('cancel-budget-button');
            const budgetForm = document.getElementById('budget-form');
            const budgetIdInput = document.getElementById('budget-id');
            const budgetCategorySelect = document.getElementById('budget-category');
            const budgetAmountInput = document.getElementById('budget-amount');
            const budgetModalTitle = document.getElementById('budget-modal-title');


            // Botões de Sair
            const logoutButtonDesktop = document.getElementById('logout-button-desktop');
            const logoutButtonMobile = document.getElementById('logout-button-mobile');

            // Carrega todos os dados do Firestore
            async function loadAllDataFromFirestore() {
                console.log("loadAllDataFromFirestore called. userId:", userId, "isAuthReady:", isAuthReady);
                if (!isAuthReady || !userId) {
                    console.warn("Autenticação não pronta ou userId ausente para carregar dados do Firestore. Abortando load.");
                    return;
                }

                // Listener para AI Config - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('settings', 'aiConfig'), (docSnap) => {
                    if (docSnap.exists()) {
                        aiConfig = { ...aiConfig, ...docSnap.data() }; // Mescla com os defaults
                    }
                    // Popula os campos da UI com os valores carregados ou padrão
                    aiPersonaInput.value = aiConfig.persona;
                    aiSympathySlider.value = aiConfig.sympathy;
                    aiSympathyLabel.textContent = getSympathyLabel(aiConfig.sympathy);
                    aiDepthSlider.value = aiConfig.depth;
                    aiDepthLabel.textContent = getDepthLabel(aiConfig.depth);
                    
                    if (!docSnap.exists()) {
                        console.log("AI Config não encontrada, salvando padrão.");
                        saveAiConfig(); // Salva a configuração padrão se não existir
                    }
                }, (error) => {
                    console.error("Erro ao carregar AI Config do Firestore:", error);
                });

                // Listener para Categorias (que agora incluem Caixinhas) - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('categories', 'userCategories'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().items) {
                        categories = docSnap.data().items;
                        console.log("Categorias e Caixinhas carregadas do Firestore.");
                        renderCategories(categorySearchInput.value);
                        updateDashboardAndTransactionSummaries(); // Atualiza os resumos após carregar categorias
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    } else { // Se não existir ou estiver vazio, inicializa como array vazio
                        categories = [];
                        console.log("Categorias e Caixinhas não encontradas ou vazias, inicializando como array vazio.");
                        saveCategories(); // Salva para criar o documento vazio se não existir
                        renderCategories(categorySearchInput.value);
                        updateDashboardAndTransactionSummaries();
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    }
                }, (error) => {
                    console.error("Erro ao carregar Categorias do Firestore:", error);
                });

                // Listener para Orçamentos - Usa getUserDocumentRef
                onSnapshot(getUserDocumentRef('budgets', 'userBudgets'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().items) {
                        budgets = docSnap.data().items;
                        console.log("Orçamentos carregados do Firestore.");
                        renderBudgets();
                    } else { // Se não existir ou estiver vazio, inicializa como array vazio
                        budgets = [];
                        console.log("Orçamentos não encontrados ou vazios, inicializando como array vazio.");
                        saveBudgets(); // Salva para criar o documento vazio se não existir
                        renderBudgets();
                    }
                }, (error) => {
                    console.error("Erro ao carregar Orçamentos do Firestore:", error);
                });

                // Listener para Chaves de API Gemini (ARRAY) - NOVO
                onSnapshot(getUserDocumentRef('settings', 'geminiApiKeys'), (docSnap) => {
                    if (docSnap.exists() && docSnap.data().keys && Array.isArray(docSnap.data().keys)) {
                        geminiApiKeys = docSnap.data().keys;
                        // Popula os campos do modal com as chaves salvas
                        modalApiKeyInputs.forEach((input, index) => {
                            input.value = geminiApiKeys[index] || '';
                        });
                        updateApiModalStatus("Chaves de API carregadas.", "info");
                        isGeminiApiReady = geminiApiKeys.some(key => key.trim() !== ''); // Pronto se houver qualquer chave
                        console.log("Chaves de API Gemini carregadas do Firestore.");
                    } else {
                        geminiApiKeys = [];
                        modalApiKeyInputs.forEach(input => input.value = ''); // Limpa os campos
                        updateApiModalStatus("Nenhuma chave de API salva ainda. Por favor, insira e salve.", "info");
                        isGeminiApiReady = false;
                        console.log("Chaves de API Gemini não encontradas no Firestore.");
                    }
                    updateChatUIState();
                }, (error) => {
                    console.error("Erro ao carregar Chaves de API Gemini do Firestore:", error);
                    geminiApiKeys = [];
                    updateApiModalStatus(`Erro ao carregar chaves de API: ${error.message}`, "error");
                    isGeminiApiReady = false;
                    updateChatUIState();
                });

                // Listener para Transações - Usa getUserCollectionRef
                const transactionsColRef = getUserCollectionRef('transactions');
                if (transactionsColRef) { // Verifica se a referência foi criada com sucesso
                    onSnapshot(query(transactionsColRef, orderBy('date', 'desc')), (querySnapshot) => {
                        transactions = [];
                        querySnapshot.forEach((doc) => {
                            transactions.push({ id: doc.id, ...doc.data() });
                        });
                        console.log("Transações carregadas do Firestore.");
                        renderTransactions();
                        updateDashboardAndTransactionSummaries();
                        renderExpenseChart(); // Adicionar chamada para o gráfico
                    }, (error) => {
                        console.error("Erro ao carregar Transações do Firestore:", error);
                    });
                }
            }

            // Função para exibir o status de salvamento (NOVO)
            function showAiConfigSaveStatus() {
                aiConfigStatusMessage.classList.remove('hidden');
                setTimeout(() => {
                    aiConfigStatusMessage.classList.add('hidden');
                }, 2000); // A mensagem desaparece após 2 segundos
            }

            // Salva a configuração da IA no Firestore (ATUALIZADO)
            async function saveAiConfig() {
                if (!isAuthReady || !userId) {
                    console.warn("Autenticação não pronta ou userId ausente.");
                    return;
                }
                try {
                    const aiConfigRef = getUserDocumentRef('settings', 'aiConfig');
                    if (aiConfigRef) {
                        await setDoc(aiConfigRef, aiConfig, { merge: true }); // Usar merge para não sobrescrever
                        showAiConfigSaveStatus();
                        console.log("Configurações da IA salvas automaticamente.");
                    }
                } catch (error) {
                    console.error("Erro ao salvar AI Config:", error);
                    // Não exibe mensagem de erro na UI para auto-save, apenas no console
                }
            }

            // Salva categorias no Firestore (como um único documento com array)
            // Agora lida com categorias normais e caixinhas
            async function saveCategories() {
                if (!isAuthReady || !userId) { 
                    console.warn("saveCategories: Autenticação não pronta ou userId ausente. Tentando salvar localmente por agora.");
                    displayCategorySaveStatus('Erro: Autenticação não pronta para salvar no banco.', 'error');
                    return; 
                }
                try {
                    const userCategoriesRef = getUserDocumentRef('categories', 'userCategories');
                    if (userCategoriesRef) {
                        await setDoc(userCategoriesRef, { items: categories || [] }); 
                        console.log("saveCategories: Categorias e Caixinhas salvas com sucesso no Firestore!");
                        displayCategorySaveStatus('Categoria/Caixinha salva com sucesso! &#x1F389;', 'success');
                    }
                } catch (error) {
                    console.error("saveCategories: Erro ao salvar Categorias no Firestore:", error);
                    displayCategorySaveStatus(`Erro ao salvar: ${error.message}`, 'error');
                }
            }

            // Salva uma transação individual no Firestore (adicione ou atualize)
            async function saveTransaction(transactionData) {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    const transactionsColRef = getUserCollectionRef('transactions');
                    if (transactionsColRef) {
                        if (transactionData.id) {
                            await setDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions`, transactionData.id), transactionData);
                        } else {
                            await addDoc(transactionsColRef, transactionData);
                        }
                    }
                } catch (error) {
                    console.error("Erro ao salvar Transação:", error);
                }
            }

            // Deleta uma transação individual do Firestore
            async function deleteTransactionFromFirestore(id) {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    await deleteDoc(doc(db, `artifacts/${appId}/users/${userId}/transactions`, id));
                } catch (error) {
                    console.error("Erro ao deletar Transação:", error);
                }
            }

            // Salva orçamentos no Firestore (como um único documento com array)
            async function saveBudgets() {
                if (!isAuthReady || !userId) { console.warn("Autenticação não pronta ou userId ausente."); return; }
                try {
                    const userBudgetsRef = getUserDocumentRef('budgets', 'userBudgets');
                    if (userBudgetsRef) {
                        await setDoc(userBudgetsRef, { items: budgets || [] }); 
                    }
                } catch (error) {
                    console.error("Erro ao salvar Orçamentos:", error);
                }
            }

            // Salva as chaves da API Gemini no Firestore (ARRAY) - ATUALIZADO
            async function saveApiKeys() {
                if (!isAuthReady || !userId) { 
                    updateApiModalStatus("Erro: Autenticação não pronta para salvar as chaves de API.", "error");
                    return; 
                }
                const keysToSave = modalApiKeyInputs.map(input => input.value.trim());
                
                // Validação simples: pelo menos uma chave deve ser preenchida
                if (keysToSave.every(key => key === '')) {
                    updateApiModalStatus("Por favor, insira pelo menos uma chave de API válida.", "error");
                    return;
                }

                try {
                    const apiKeyRef = getUserDocumentRef('settings', 'geminiApiKeys');
                    if (apiKeyRef) {
                        await setDoc(apiKeyRef, { keys: keysToSave });
                        geminiApiKeys = keysToSave; // Atualiza o array local
                        updateApiModalStatus("Chaves de API salvas com sucesso! &#x1F389;", "success");
                        isGeminiApiReady = geminiApiKeys.some(key => key.trim() !== '');
                        updateChatUIState();
                        console.log("Chaves de API Gemini salvas no Firestore.");
                    }
                } catch (error) {
                    console.error("Erro ao salvar Chaves de API Gemini no Firestore:", error);
                    updateApiModalStatus(`Erro ao salvar chaves de API: ${error.message}`, "error");
                }
            }
            // --- FIM das Funções de Persistência (Firebase Firestore) ---

            await initializeFirebase();
            
            // A função loadApiKey agora é disparada pelo onSnapshot dentro de loadAllDataFromFirestore
            // e não precisa mais ser chamada explicitamente aqui ou em openApiKeysModal.
            // A UI de chat será atualizada pelo onSnapshot da chave de API.

            // --- Funções de UI e Navegação ---

            // Função para exibir a página correta
            function showPage(pageId) {
                pageSections.forEach(section => {
                    section.classList.remove('active');
                });
                const activePage = document.getElementById(pageId);
                if (activePage) {
                    activePage.classList.add('active');
                }

                // Atualizar o estado ativo dos links de navegação
                navLinks.forEach(link => {
                    link.classList.remove('active');
                    if (link.dataset.page === pageId && (link.classList.contains('nav-link') || link.classList.contains('mobile-nav-item'))) {
                        link.classList.add('active');
                    }
                });

                // Ações específicas ao carregar cada página
                if (pageId === 'chat') {
                    chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
                } else if (pageId === 'categories-management') {
                    renderCategories();
                } else if (pageId === 'transactions') {
                    renderTransactions();
                    updateDashboardAndTransactionSummaries();
                } 
                else if (pageId === 'dashboard') {
                    updateDashboardAndTransactionSummaries();
                    renderExpenseChart(); // Garante que o gráfico é renderizado ao voltar para o dashboard
                } else if (pageId === 'budget-management') {
                    renderBudgets();
                } else if (pageId === 'ai-config') {
                    // Os valores já são populados pelo onSnapshot, mas garantimos que os labels estão corretos.
                    aiPersonaInput.value = aiConfig.persona;
                    aiSympathySlider.value = aiConfig.sympathy;
                    aiSympathyLabel.textContent = getSympathyLabel(aiConfig.sympathy);
                    aiDepthSlider.value = aiConfig.depth;
                    aiDepthLabel.textContent = getDepthLabel(aiConfig.depth);
                }
            }

            // Função para atualizar os cards de resumo no Dashboard e Transações
            function updateDashboardAndTransactionSummaries() {
                let totalIncome = 0;
                let totalExpenses = 0;
                let currentBalance = 0;

                transactions.forEach(t => {
                    // Determina o tipo de transação para cálculo de saldo
                    let effectiveType = t.type;
                    if (t.type === 'caixinha') {
                        effectiveType = t.transactionType === 'deposit' ? 'expense' : 'income'; // Depósito é uma "despesa" do saldo principal, resgate é uma "receita"
                    }

                    if (effectiveType === 'income' && (t.status === 'Recebido' || t.status === 'Pago' || t.status === 'Confirmado')) { 
                        totalIncome += parseFloat(t.amount);
                    } else if (effectiveType === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')) { 
                        totalExpenses += parseFloat(t.amount);
                    }
                });
                currentBalance = totalIncome - totalExpenses;

                // Atualiza Dashboard
                dashboardCurrentBalance.textContent = formatCurrency(currentBalance);
                dashboardMonthlyIncome.textContent = formatCurrency(totalIncome);
                dashboardMonthlyExpenses.textContent = formatCurrency(totalExpenses);

                // Atualiza Resumo em Transações
                transactionsCurrentBalance.textContent = formatCurrency(currentBalance);
                transactionsTotalExpenses.textContent = formatCurrency(totalExpenses);

                // Atualiza Total Guardado (Caixinhas) - Agora filtra das categorias
                let totalCaixinhasSaved = categories
                    .filter(cat => cat.type === 'caixinha')
                    .reduce((sum, caixinha) => sum + parseFloat(caixinha.savedAmount || 0), 0); 
                transactionsTotalCaixinhasSaved.textContent = formatCurrency(totalCaixinhasSaved); 
            }


            // --- Funções de Gerenciamento de Categorias ---

            /**
             * Retorna a próxima cor disponível para uma categoria com base no seu tipo e prioridade.
             * A função tenta encontrar uma cor que ainda não esteja em uso por outras categorias
             * do mesmo tipo/prioridade. Se todas as cores da paleta estiverem em uso, ela cicla.
             * @param {string} type - O tipo da categoria ('income', 'expense', 'caixinha').
             * @param {string} [priority] - A prioridade da categoria ('essential', 'non-essential'), aplicável apenas a 'expense'.
             * @returns {string} A cor hexadecimal selecionada.
             */
            function getNextAvailableColor(type, priority = null) {
                let palette;
                if (type === 'income') {
                    palette = INCOME_COLORS;
                } else if (type === 'expense') {
                    palette = (priority === 'essential') ? ESSENTIAL_COLORS : NON_ESSENTIAL_COLORS;
                } else if (type === 'caixinha') {
                    palette = CAIXINHA_COLORS;
                } else {
                    return '#9E9E9E'; // Cor padrão de fallback
                }

                // Filtra as categorias existentes para encontrar as do mesmo tipo/prioridade
                const relevantCategories = categories.filter(cat => {
                    if (cat.type !== type) return false;
                    if (type === 'expense' && cat.priority !== priority) return false;
                    return true;
                });

                const usedColors = new Set(relevantCategories.map(cat => cat.color));

                // Tenta encontrar uma cor não utilizada
                for (const color of palette) {
                    if (!usedColors.has(color)) {
                        return color;
                    }
                }

                // Se todas foram usadas, reutiliza de forma cíclica
                return palette[relevantCategories.length % palette.length];
            }

            // Função para renderizar as categorias (e caixinhas) na lista
            function renderCategories(filter = '') {
                categoryListContainer.innerHTML = '';

                const filteredCategories = categories.filter(cat => 
                    cat.name.toLowerCase().includes(filter.toLowerCase())
                );

                if (filteredCategories.length === 0 && filter === '') {
                    categoryListContainer.innerHTML = '<p class="text-center text-gray-500 py-4">Nenhuma categoria ou caixinha cadastrada. Adicione uma nova!</p>';
                } else if (filteredCategories.length === 0 && filter !== '') {
                    categoryListContainer.innerHTML = `<p class="text-center text-gray-500 py-4">Nenhuma categoria ou caixinha encontrada para "${filter}".</p>`;
                }

                filteredCategories.forEach(category => {
                    const categoryItem = document.createElement('div');
                    categoryItem.className = 'bg-white p-4 rounded-lg shadow-sm flex items-center justify-between';
                    
                    let typeDisplay = '';
                    let priorityDisplay = '';
                    let savedAmountDisplay = '';
                    let progressHtml = '';

                    if (category.type === 'income') {
                        typeDisplay = 'Receita';
                    } else if (category.type === 'expense') {
                        typeDisplay = 'Despesa';
                        priorityDisplay = category.priority ? ` (${category.priority === 'essential' ? 'Essencial' : 'Não Essencial'})` : '';
                    } else if (category.type === 'caixinha') {
                        typeDisplay = 'Caixinha';
                        const saved = parseFloat(category.savedAmount || 0);
                        const target = parseFloat(category.targetAmount || 0);
                        const progress = (target > 0) ? (saved / target) * 100 : 0;
                        const progressBarColor = progress >= 100 ? 'bg-green-500' : (progress > 50 ? 'bg-blue-500' : 'bg-yellow-500');

                        savedAmountDisplay = ` - Guardado: ${formatCurrency(saved)} / Alvo: ${formatCurrency(target)}`;
                        progressHtml = `
                            <div class="w-full bg-gray-200 rounded-full h-2.5 dark:bg-gray-700 mt-2">
                                <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${Math.min(100, progress)}%"></div>
                            </div>
                            <p class="text-xs text-gray-500 mt-1">${progress.toFixed(0)}% Concluído</p>
                        `;
                    }

                    categoryItem.innerHTML = `
                        <div class="flex items-center">
                            <div class="w-6 h-6 rounded-full mr-3" style="background-color: ${category.color};"></div>
                            <div>
                                <p class="font-medium text-lg">${category.name}</p>
                                <p class="text-sm text-gray-500">${typeDisplay}${priorityDisplay}${savedAmountDisplay}</p>
                                ${progressHtml}
                            </div>
                        </div>
                        <div class="flex items-center space-x-2">
                            <button class="text-gray-500 hover:text-blue-500 p-1 rounded-full edit-category-button" data-id="${category.id}">
                                <i class="fa-solid fa-pen-to-square text-lg"></i>
                            </button>
                            <button class="text-gray-500 hover:text-red-500 p-1 rounded-full delete-category-button" data-id="${category.id}">
                                <i class="fa-solid fa-trash-can text-lg"></i>
                            </button>
                        </div>
                    `;
                    categoryListContainer.appendChild(categoryItem);
                });
            }

            // Abre o modal de categoria (agora também para caixinhas)
            function openCategoryModal(category = null) {
                categoryModal.classList.add('active');
                categorySaveStatusMessage.classList.add('hidden');
                categoryForm.reset(); // Limpa o formulário
                categoryTargetAmountInput.value = ''; // Limpa o campo de valor alvo

                if (category) {
                    categoryModalTitle.textContent = 'Editar Categoria';
                    categoryIdInput.value = category.id;
                    categoryNameInput.value = category.name;
                    document.querySelector(`input[name="category-type"][value="${category.type}"]`).checked = true;
                    
                    // Controla a visibilidade do campo de prioridade
                    if (category.type === 'expense') {
                        priorityField.style.display = 'block';
                        document.querySelector(`input[name="category-priority"][value="${category.priority || 'essential'}"]`).checked = true;
                    } else {
                        priorityField.style.display = 'none';
                    }

                    // Controla a visibilidade e preenche o campo de valor alvo para caixinhas
                    if (category.type === 'caixinha') {
                        targetAmountField.style.display = 'block';
                        categoryTargetAmountInput.value = (parseFloat(category.targetAmount || 0) * 100).toFixed(0);
                        formatCurrencyInput(categoryTargetAmountInput); // Formata o valor
                    } else {
                        targetAmountField.style.display = 'none';
                    }

                } else { // Adicionar nova categoria/caixinha
                    categoryModalTitle.textContent = 'Adicionar Nova Categoria ou Caixinha';
                    categoryIdInput.value = '';
                    categoryNameInput.value = '';
                    document.querySelector('input[name="category-type"][value="expense"]').checked = true; // Padrão para Despesa
                    priorityField.style.display = 'block'; // Visível por padrão para despesa
                    document.querySelector(`input[name="category-priority"][value="essential"]`).checked = true;
                    targetAmountField.style.display = 'none'; // Escondido por padrão
                }
            }

            // Fecha o modal de categoria
            function closeCategoryModal() {
                categoryModal.classList.remove('active');
                categoryForm.reset();
                categorySaveStatusMessage.classList.add('hidden');
            }

            // Exibe mensagem de status para salvar categoria
            function displayCategorySaveStatus(message, type = 'info') {
                categorySaveStatusMessage.textContent = message;
                categorySaveStatusMessage.classList.remove('hidden', 'text-green-700', 'text-red-700', 'text-blue-700');
                if (type === 'success') {
                    categorySaveStatusMessage.classList.add('text-green-700');
                } else if (type === 'error') {
                    categorySaveStatusMessage.classList.add('text-red-700');
                } else {
                    categorySaveStatusMessage.classList.add('text-blue-700');
                }
                setTimeout(() => {
                    categorySaveStatusMessage.classList.add('hidden');
                }, 3000);
            }

            // Lida com o envio do formulário de categoria
            categoryForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const id = categoryIdInput.value;
                const name = categoryNameInput.value.trim();
                const type = document.querySelector('input[name="category-type"]:checked').value;
                
                if (!name) {
                    displayCategorySaveStatus('O nome da categoria é obrigatório!', 'error');
                    return;
                }
                
                let priority = (type === 'expense') ? document.querySelector('input[name="category-priority"]:checked').value : null;
                let targetAmount = null;
                let savedAmount = null;

                if (type === 'caixinha') {
                    const targetAmountFormatted = categoryTargetAmountInput.value.replace(/\./g, '').replace(',', '.');
                    targetAmount = parseFloat(targetAmountFormatted) || 0;
                    // Se estiver editando uma caixinha existente, mantém o savedAmount
                    if (id) {
                        const existingCategory = categories.find(cat => cat.id === id);
                        savedAmount = existingCategory ? existingCategory.savedAmount : 0;
                    } else {
                        // Se for uma nova caixinha, o valor guardado começa em 0
                        savedAmount = 0;
                    }
                }

                if (id) { // Editando uma categoria existente
                    const index = categories.findIndex(cat => cat.id === id);
                    if (index !== -1) {
                        const originalCategory = categories[index];
                        const mudouTipo = originalCategory.type !== type;
                        const mudouPrioridade = originalCategory.priority !== priority;
                                                
                        // Mantém a cor se o tipo/prioridade não mudar
                        let newColor = originalCategory.color; 
                                                
                        // Recalcula a cor apenas se o tipo ou prioridade mudou
                        if (mudouTipo || mudouPrioridade) {
                            newColor = getNextAvailableColor(type, priority);
                        }
                        categories[index] = { 
                            ...originalCategory, 
                            name, 
                            type, 
                            priority, 
                            color: newColor,
                            targetAmount: targetAmount, // Atualiza targetAmount
                            savedAmount: savedAmount // Atualiza savedAmount
                        };
                    }
                } else { // Criando uma nova categoria
                    const newColor = getNextAvailableColor(type, priority);
                    const newCategory = { 
                        id: generateUUID(), 
                        name, 
                        type, 
                        priority, 
                        color: newColor,
                        targetAmount: targetAmount,
                        savedAmount: savedAmount
                    };
                                        
                    categories.push(newCategory);
                }
                await saveCategories();
                
                if(transactionModal.classList.contains('active')) {
                    // populateTransactionCategories(document.querySelector('input[name="transaction-type"]:checked').value); // Removido, a lógica de populate é no goToStep(2)
                }
                closeCategoryModal(); // Fecha o modal após salvar
            });

            // Lida com cliques nos botões de editar/excluir categorias (delegação de eventos)
            categoryListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.edit-category-button')) {
                    const id = e.target.closest('.edit-category-button').dataset.id;
                    const categoryToEdit = categories.find(cat => cat.id === id);
                    if (categoryToEdit) {
                        openCategoryModal(categoryToEdit);
                    }
                } else if (e.target.closest('.delete-category-button')) {
                    const id = e.target.closest('.delete-category-button').dataset.id;
                    const categoryToDelete = categories.find(cat => cat.id === id);

                    showConfirmationModal(
                        "Confirmar Exclusão",
                        `Tem certeza que deseja excluir a categoria "${categoryToDelete.name}"? Todas as transações associadas a ela ficarão sem categoria.`,
                        async () => {
                            categories = categories.filter(cat => cat.id !== id);
                            const transactionsToUpdate = transactions.filter(t => t.categoryId === id);
                            for (const t of transactionsToUpdate) {
                                t.categoryId = 'unknown'; // Define como categoria desconhecida
                                t.transactionType = null; // Limpa o tipo de transação se for caixinha
                                t.caixinhaId = null; // Limpa o ID da caixinha
                                await saveTransaction(t);
                            }
                            await saveCategories();
                            // if(transactionModal.classList.contains('active')) { // Removido, a lógica de populate é no goToStep(2)
                            //     populateTransactionCategories(document.querySelector('input[name="transaction-type"]:checked').value);
                            // }
                            updateDashboardAndTransactionSummaries();
                        }
                    );
                }
            });

            // Lógica para mostrar/esconder o campo de prioridade e valor alvo
            categoryTypeRadios.forEach(radio => {
                radio.addEventListener('change', (event) => {
                    const selectedType = event.target.value;
                    // Mostra/esconde campo de prioridade
                    priorityField.style.display = (selectedType === 'expense') ? 'block' : 'none';
                    // Mostra/esconde campo de valor alvo
                    targetAmountField.style.display = (selectedType === 'caixinha') ? 'block' : 'none';
                    // Limpa o valor do campo alvo se não for caixinha
                    if (selectedType !== 'caixinha') {
                        categoryTargetAmountInput.value = '';
                    }
                });
            });

            // Listener para formatar o input de valor alvo da categoria/caixinha
            categoryTargetAmountInput.addEventListener('input', () => {
                formatCurrencyInput(categoryTargetAmountInput);
            });


            // --- Funções de Gerenciamento de Transações ---

            // Função para popular o dropdown de categorias (e caixinhas) no modal de transações
            function populateTransactionCategories(selectedTransactionType = null) {
                transactionCategorySelect.innerHTML = '<option value="">Selecione uma Categoria</option>';

                let filteredCategories = [];
                // A lógica aqui precisa ser mais inteligente para o novo fluxo:
                // Se for 'income' ou 'expense', filtra por essas categorias.
                // Se for 'deposit' ou 'withdraw', filtra por categorias do tipo 'caixinha'.
                if (selectedTransactionType === 'expense' || selectedTransactionType === 'income') {
                    filteredCategories = categories.filter(cat => cat.type === selectedTransactionType);
                } else if (selectedTransactionType === 'deposit' || selectedTransactionType === 'withdraw') {
                    filteredCategories = categories.filter(cat => cat.type === 'caixinha');
                }

                if (filteredCategories.length > 0) {
                    filteredCategories.forEach(cat => {
                        const option = document.createElement('option');
                        option.value = cat.id;
                        option.textContent = cat.name; 
                        transactionCategorySelect.appendChild(option);
                    });
                } else {
                    transactionCategorySelect.innerHTML += '<option value="" disabled>Nenhuma categoria disponível para este tipo</option>';
                }
            }


            // Renderiza as transações
            function renderTransactions() {
                transactionsListContainer.innerHTML = `
                    <div class="absolute left-3 top-0 bottom-0 w-0.5 bg-gray-200"></div>
                `; 

                if (transactions.length === 0) {
                    transactionsListContainer.innerHTML += '<p class="text-center text-gray-500 py-4" id="no-transactions-message">Nenhuma transação cadastrada ainda.</p>';
                    return;
                }

                const groupedTransactions = transactions.reduce((acc, transaction) => {
                    const date = transaction.date;
                    if (!acc[date]) {
                        acc[date] = [];
                    }
                    acc[date].push(transaction);
                    return acc;
                }, {});

                const sortedDates = Object.keys(groupedTransactions).sort((a, b) => new Date(b) - new Date(a));

                sortedDates.forEach(date => {
                    const dateGroupDiv = document.createElement('div');
                    dateGroupDiv.className = 'mb-6 relative pl-8';

                    const formattedDate = new Date(date + 'T12:00:00').toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });

                    dateGroupDiv.innerHTML = `
                        <div class="timeline-bullet-date">
                            <i class="fa-solid fa-calendar-days text-sm"></i>
                        </div>
                        <h3 class="text-xl font-semibold mb-3 ml-2">${formattedDate}</h3>
                        <div class="space-y-3"></div>
                    `;
                    const transactionsForDateDiv = dateGroupDiv.querySelector('.space-y-3');

                    groupedTransactions[date].sort((a, b) => {
                        const dateA = new Date(a.date);
                        const dateB = new Date(b.date);
                        if (dateA.getTime() === dateB.getTime()) {
                            return a.description.localeCompare(b.description);
                        }
                        return dateB - dateA;
                    }).forEach(transaction => {
                        let categoryName = 'Categoria Desconhecida';
                        let bulletColor = '#9E9E9E';
                        let amountColorClass = '';
                        let amountPrefix = '';
                        let transactionTypeDisplay = '';

                        const category = categories.find(cat => cat.id === transaction.categoryId);
                        if (category) {
                            categoryName = category.name;
                            bulletColor = category.color;
                            transactionTypeDisplay = category.type;
                        } else {
                            // Fallback for unknown categories, e.g., after deletion
                            categoryName = 'Categoria Desconhecida';
                            bulletColor = '#9E9E9E';
                            transactionTypeDisplay = transaction.type; // Use transaction's own type if category not found
                        }

                        if (transaction.type === 'income') {
                            amountColorClass = 'text-[var(--color-green-positive)]';
                            amountPrefix = '+';
                        } else if (transaction.type === 'expense') {
                            amountColorClass = 'text-[var(--color-red-negative)]';
                            amountPrefix = '-';
                        } else if (transaction.type === 'caixinha') {
                            if (transaction.transactionType === 'deposit') {
                                amountColorClass = 'text-[var(--color-red-negative)]'; // Saída do saldo principal
                                amountPrefix = '-';
                                categoryName = `Depósito: ${categoryName}`;
                            } else if (transaction.transactionType === 'withdraw') {
                                amountColorClass = 'text-[var(--color-green-positive)]'; // Entrada no saldo principal
                                amountPrefix = '+';
                                categoryName = `Resgate: ${categoryName}`;
                            }
                        }
                        
                        // Determina se a bolinha deve ser preenchida ou vazada
                        const isPaidOrReceived = (transaction.status === 'Pago' || transaction.status === 'Recebido' || transaction.status === 'Confirmado');
                        const bulletClass = isPaidOrReceived ? 'transaction-bullet paid' : 'transaction-bullet';
                        const bulletStyle = isPaidOrReceived ? `background-color: ${bulletColor};` : `border: 3px solid ${bulletColor};`;
                        
                        // NOVO: Status indicator em nova linha, menor e mais suave
                        const statusIndicatorText = transaction.status === 'Pendente' ? 'Pendente' : 
                                                    (transaction.type === 'income' && transaction.status === 'Recebido' ? 'Recebido' : 
                                                    (transaction.type === 'expense' && transaction.status === 'Pago' ? 'Pago' : 
                                                    (transaction.type === 'caixinha' && transaction.transactionType === 'deposit' && transaction.status === 'Confirmado' ? 'Guardado' : 
                                                    (transaction.type === 'caixinha' && transaction.transactionType === 'withdraw' && transaction.status === 'Confirmado' ? 'Resgatado' : ''))));
                        const statusIndicatorHtml = statusIndicatorText ? `<p class="text-xs text-gray-500">${statusIndicatorText}</p>` : '';


                        const transactionItem = document.createElement('div');
                        // Ajustado pl-12 para pl-8
                        transactionItem.className = `bg-white p-4 rounded-lg shadow-sm flex justify-between items-center relative pl-8`; 
                        transactionItem.innerHTML = `
                            <div class="${bulletClass}" style="${bulletStyle}"></div>
                            <div class="flex-grow min-w-0">
                                <p class="font-medium truncate text-gray-800">${categoryName}</p>
                                ${statusIndicatorHtml} <!-- Status em nova linha -->
                                <p class="text-sm text-gray-500 truncate">${transaction.description}</p>
                            </div>
                            <div class="flex items-center space-x-2 ml-4">
                                <p class="font-bold text-lg ${amountColorClass}">${amountPrefix} ${formatCurrency(transaction.amount)}</p>
                                <!-- Menu de 3 pontos para Desktop -->
                                <div class="relative hidden md:block">
                                    <button class="transaction-menu-button p-2 rounded-full hover:bg-gray-100" data-id="${transaction.id}">
                                        <i class="fa-solid fa-ellipsis-vertical text-gray-500"></i>
                                    </button>
                                    <div class="transaction-menu-dropdown absolute right-0 mt-2 w-40 bg-white rounded-md shadow-lg z-20 hidden">
                                        <a href="#" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 edit-transaction-button" data-id="${transaction.id}">Editar</a>
                                        <a href="#" class="block px-4 py-2 text-sm text-red-500 hover:bg-gray-100 delete-transaction-button" data-id="${transaction.id}">Apagar</a>
                                    </div>
                                </div>
                                <!-- Botões para Mobile (visíveis por padrão, swipe seria uma melhoria futura) -->
                                <div class="md:hidden flex space-x-1">
                                    <button class="text-gray-400 hover:text-blue-500 p-1 rounded-full edit-transaction-button" data-id="${transaction.id}">
                                        <i class="fa-solid fa-pen-to-square text-base"></i>
                                    </button>
                                    <button class="text-gray-400 hover:text-red-500 p-1 rounded-full delete-transaction-button" data-id="${transaction.id}">
                                        <i class="fa-solid fa-trash-can text-base"></i>
                                    </button>
                                </div>
                            </div>
                        `;
                        transactionsForDateDiv.appendChild(transactionItem);
                    });
                    transactionsListContainer.appendChild(dateGroupDiv);
                });
                if (transactions.length > 0) {
                    noTransactionsMessage.classList.add('hidden');
                } else {
                    noTransactionsMessage.classList.remove('hidden');
                }
            }

            // Função para atualizar as opções de status com botões de rádio
            function updateTransactionStatusOptions(transactionType) {
                const statusContainer = document.getElementById('transaction-status-options');
                statusContainer.innerHTML = '';
                let options = [];
                if (transactionType === 'income') {
                    options = [{ value: 'Recebido', label: 'Recebido' }, { value: 'Pendente', label: 'Pendente' }];
                } else if (transactionType === 'expense') {
                    options = [{ value: 'Pago', label: 'Pago' }, { value: 'Pendente', label: 'Pendente' }];
                } else { // caixinha (deposit/withdraw)
                    options = [{ value: 'Confirmado', label: 'Confirmado' }]; // Simplificado para caixinhas
                }

                options.forEach((opt, index) => {
                    const wrapper = document.createElement('div');
                    const input = document.createElement('input');
                    input.type = 'radio';
                    input.name = 'transaction-status-radio'; // Novo nome para evitar conflito com o select removido
                    input.id = `status-${opt.value}`;
                    input.value = opt.value;
                    input.className = 'hidden peer';
                    if (index === 0) input.checked = true; // Marca a primeira opção como padrão

                    const label = document.createElement('label');
                    label.htmlFor = `status-${opt.value}`;
                    label.textContent = opt.label;
                    label.className = 'px-4 py-2 border rounded-lg cursor-pointer transition peer-checked:bg-[var(--color-blue-primary)] peer-checked:text-white peer-checked:border-[var(--color-blue-primary)]';
                    
                    wrapper.appendChild(input);
                    wrapper.appendChild(label);
                    statusContainer.appendChild(wrapper);
                });
            }

            // Função para controlar a visibilidade das etapas do modal de transação
            function goToStep(stepNumber) {
                if (stepNumber < 1 || stepNumber > totalSteps) {
                    console.error("Tentativa de ir para uma etapa inválida:", stepNumber);
                    return;
                }
                currentStep = stepNumber;
                transactionSteps.forEach((step, index) => {
                    step.classList.toggle('hidden', index + 1 !== currentStep);
                });

                // Ações específicas para cada etapa ao navegar
                if (currentStep === 2) {
                    const selectedType = document.querySelector('input[name="transaction-type"]:checked').value;
                    populateTransactionCategories(selectedType);
                    updateTransactionStatusOptions(selectedType); // Atualiza status options para o tipo selecionado
                    transactionAmountInput.focus(); // Foca no campo de valor
                } else if (currentStep === 3) {
                    transactionDescriptionInput.focus(); // Foca no campo de descrição
                } else if (currentStep === 4) {
                    // Seleciona o status correto se estiver editando
                    if (transactionIdInput.value) {
                        const transactionToEdit = transactions.find(t => t.id === transactionIdInput.value);
                        if (transactionToEdit) {
                            const statusRadio = document.querySelector(`input[name="transaction-status-radio"][value="${transactionToEdit.status}"]`);
                            if (statusRadio) {
                                statusRadio.checked = true;
                            }
                        }
                    }
                    // Foca no primeiro botão de rádio de status
                    const firstStatusRadio = transactionStatusOptionsContainer.querySelector('input[type="radio"]');
                    if (firstStatusRadio) {
                        firstStatusRadio.focus();
                    }
                }
            }

            // Abre o modal de transação (agora apenas reseta e vai para a primeira etapa)
            function openTransactionModal(transaction = null) {
                transactionModal.classList.add('active');
                transactionForm.reset();
                transactionDateInput.valueAsDate = new Date(); // Define data padrão
                
                if (transaction) {
                    transactionIdInput.value = transaction.id;
                    transactionDescriptionInput.value = transaction.description;
                    transactionAmountInput.value = (parseFloat(transaction.amount) * 100).toFixed(0);
                    formatCurrencyInput(transactionAmountInput);
                    transactionDateInput.value = transaction.date;

                    // Marca o tipo de transação correto para edição
                    let typeToSelect = transaction.type;
                    if (transaction.type === 'caixinha') {
                        typeToSelect = transaction.transactionType; // 'deposit' ou 'withdraw'
                    }
                    const typeButton = document.querySelector(`.step-1-type-button[data-type="${typeToSelect}"]`);
                    if (typeButton) {
                        document.querySelectorAll('.step-1-type-button').forEach(btn => btn.classList.remove('selected'));
                        typeButton.classList.add('selected');
                        document.querySelector(`input[name="transaction-type"][value="${typeToSelect}"]`).checked = true;
                    }
                    
                    // Preenche a categoria e o status
                    populateTransactionCategories(typeToSelect);
                    transactionCategorySelect.value = transaction.categoryId;
                    updateTransactionStatusOptions(typeToSelect);
                    // O status é marcado na goToStep(4)
                    goToStep(2); // Pula para a etapa 2, que preencherá o restante
                } else {
                    transactionIdInput.value = ''; // Garante que o ID da transação seja limpo para novas transações
                    goToStep(1);
                    // Remove a classe 'selected' de todos os botões de tipo ao abrir o modal
                    document.querySelectorAll('.step-1-type-button').forEach(button => {
                        button.classList.remove('selected');
                    });
                }
            }

            // Fecha o modal de transação
            function closeTransactionModal() {
                transactionModal.classList.remove('active');
                transactionForm.reset();
                currentStep = 1; // Reseta para a primeira etapa ao fechar
            }

            // Lida com o envio do formulário de transação
            transactionForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                // O tipo agora vem do radio button oculto
                const typeSelectedInStep1 = document.querySelector('input[name="transaction-type"]:checked').value;
                
                const id = transactionIdInput.value;
                const description = transactionDescriptionInput.value.trim();
                
                const amountFormatted = transactionAmountInput.value.replace(/\./g, '').replace(',', '.');
                const amount = parseFloat(amountFormatted);

                const date = transactionDateInput.value;
                // ATUALIZADO: Obtém o valor do rádio selecionado
                const status = document.querySelector('input[name="transaction-status-radio"]:checked').value; 
                const categoryId = transactionCategorySelect.value;

                let transactionTypeForCaixinha = null; // 'deposit' or 'withdraw'
                let transactionCategoryType = null; // 'income', 'expense', or 'caixinha'

                // Validação básica (descrição agora é opcional)
                if (isNaN(amount) || !date || !status || !categoryId) {
                    showConfirmationModal("Erro de Validação", "Por favor, preencha todos os campos da transação corretamente (valor, data, status, categoria).", () => {});
                    return;
                }

                // Determina o tipo de transação real ('income', 'expense', 'caixinha')
                // e o tipo de movimento da caixinha ('deposit', 'withdraw')
                const selectedCategory = categories.find(cat => cat.id === categoryId);

                if (!selectedCategory) {
                    console.error("Categoria selecionada não encontrada.");
                    return;
                }

                transactionCategoryType = selectedCategory.type;

                if (selectedCategory.type === 'caixinha') {
                    // Se a categoria é uma caixinha, o 'type' da transação será 'caixinha'
                    // e 'transactionTypeForCaixinha' será 'deposit' ou 'withdraw'
                    if (typeSelectedInStep1 === 'deposit') {
                        transactionTypeForCaixinha = 'deposit';
                        selectedCategory.savedAmount = (selectedCategory.savedAmount || 0) + amount;
                    } else if (typeSelectedInStep1 === 'withdraw') {
                        transactionTypeForCaixinha = 'withdraw';
                        if ((selectedCategory.savedAmount || 0) < amount) {
                            showConfirmationModal(
                                "Erro de Resgate",
                                "O valor que você está tentando resgatar é maior do que o valor guardado nesta caixinha. Por favor, ajuste o valor.",
                                () => {} // Não faz nada ao confirmar, apenas fecha o modal
                            );
                            return; // Impede o salvamento da transação
                        }
                        selectedCategory.savedAmount -= amount;
                    }
                    await saveCategories(); // Salva o estado atualizado das categorias (que inclui a caixinha)
                }

                // Criar ou atualizar a transação
                const newTransaction = { 
                    id: id || generateUUID(), 
                    description, 
                    amount, 
                    date, 
                    type: transactionCategoryType, // Usa o tipo real da categoria
                    categoryId, 
                    status 
                };

                // Adiciona campos específicos para transações de caixinha se aplicável
                if (transactionCategoryType === 'caixinha') {
                    newTransaction.transactionType = transactionTypeForCaixinha;
                    newTransaction.caixinhaId = selectedCategory.id; // O ID da caixinha é o ID da categoria
                }

                await saveTransaction(newTransaction);
                closeTransactionModal();
            });

            // Lida com cliques nos botões de editar/excluir transações (delegação de eventos)
            transactionsListContainer.addEventListener('click', (e) => {
                // Lógica para o menu de 3 pontos (desktop)
                const menuButton = e.target.closest('.transaction-menu-button');
                if (menuButton) {
                    e.stopPropagation(); // Impede que o clique se propague e feche outros menus
                    const dropdown = menuButton.nextElementSibling;
                    // Fecha outros dropdowns abertos
                    document.querySelectorAll('.transaction-menu-dropdown').forEach(openDropdown => {
                        if (openDropdown !== dropdown) {
                            openDropdown.classList.add('hidden');
                        }
                    });
                    dropdown.classList.toggle('hidden');
                    return; // Sai da função para não acionar edit/delete diretamente
                }

                if (e.target.closest('.edit-transaction-button')) {
                    const id = e.target.closest('.edit-transaction-button').dataset.id;
                    const transactionToEdit = transactions.find(t => t.id === id);
                    if (transactionToEdit) {
                        openTransactionModal(transactionToEdit);
                    }
                } else if (e.target.closest('.delete-transaction-button')) {
                    const id = e.target.closest('.delete-transaction-button').dataset.id;
                    showConfirmationModal(
                        "Confirmar Exclusão",
                        "Tem certeza que deseja excluir esta transação?",
                        async () => {
                            const deletedTransaction = transactions.find(t => t.id === id);
                            if (deletedTransaction && deletedTransaction.type === 'caixinha' && deletedTransaction.caixinhaId) {
                                const caixinha = categories.find(c => c.id === deletedTransaction.caixinhaId); // Busca na lista de categorias
                                if (caixinha) {
                                    if (deletedTransaction.transactionType === 'deposit') {
                                        caixinha.savedAmount -= parseFloat(deletedTransaction.amount);
                                    } else if (deletedTransaction.transactionType === 'withdraw') {
                                        caixinha.savedAmount += parseFloat(deletedTransaction.amount);
                                    }
                                    await saveCategories(); // Salva as categorias atualizadas
                                }
                            }
                            await deleteTransactionFromFirestore(id);
                        }
                    );
                }
            });

            // Fecha dropdowns de transação ao clicar fora
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.transaction-menu-button') && !e.target.closest('.transaction-menu-dropdown')) {
                    document.querySelectorAll('.transaction-menu-dropdown').forEach(dropdown => {
                        dropdown.classList.add('hidden');
                    });
                }
            });

            // Listener para formatar o input de valor da transação
            transactionAmountInput.addEventListener('input', () => {
                formatCurrencyInput(transactionAmountInput);
            });


            // --- Funções de Gerenciamento de Orçamento ---
            function openBudgetModal(budget = null) {
                budgetForm.reset();
                budgetCategorySelect.innerHTML = '<option value="">Selecione uma categoria</option>';
                    
                // Popula o select com apenas as categorias de despesa
                const expenseCategories = categories.filter(c => c.type === 'expense');
                expenseCategories.forEach(cat => {
                    // Impede que categorias já orçadas neste mês apareçam para novos orçamentos
                    const isAlreadyBudgeted = budgets.some(b => b.categoryId === cat.id && b.month === getCurrentMonthYYYYMM());
                    if (!budget && isAlreadyBudgeted) return; // Se não estiver editando e já houver orçamento, pula
                    const option = document.createElement('option');
                    option.value = cat.id;
                    option.textContent = cat.name;
                    budgetCategorySelect.appendChild(option);
                });

                if (budget) {
                    budgetModalTitle.textContent = 'Editar Orçamento';
                    budgetIdInput.value = budget.id;
                    budgetCategorySelect.value = budget.categoryId;
                    budgetCategorySelect.disabled = true; // Não permite mudar a categoria na edição
                    budgetAmountInput.value = (parseFloat(budget.amount) * 100).toFixed(0); // Coloca em centavos para formatCurrencyInput
                    formatCurrencyInput(budgetAmountInput); // Formata o valor
                } else {
                    budgetModalTitle.textContent = 'Novo Orçamento Mensal';
                    budgetIdInput.value = '';
                    budgetCategorySelect.disabled = false;
                }
                budgetModal.classList.add('active');
            }

            function closeBudgetModal() {
                budgetModal.classList.remove('active');
            }

            function renderBudgets() {
                budgetListContainer.innerHTML = '';
                const currentMonthBudgets = budgets.filter(b => b.month === getCurrentMonthYYYYMM());
                if (currentMonthBudgets.length === 0) {
                    budgetListContainer.innerHTML = '<p class="text-center text-gray-500 py-4 col-span-full">Nenhum orçamento configurado para este mês.</p>';
                    return;
                }
                noBudgetsMessage.classList.add('hidden'); // Esconde a mensagem se houver orçamentos

                currentMonthBudgets.forEach(budget => {
                    const category = categories.find(c => c.id === budget.categoryId);
                    if (!category) return; // Pula se a categoria foi deletada
                    
                    // Calcula o gasto real para essa categoria no mês corrente
                    const totalSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && 
                            t.type === 'expense' && // Apenas despesas
                            t.date.startsWith(getCurrentMonthYYYYMM()) &&
                            (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado') // Apenas transações pagas/recebidas
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);

                    const progress = budget.amount > 0 ? (totalSpent / budget.amount) * 100 : 0;
                    const remaining = budget.amount - totalSpent;
                    const progressBarColor = progress >= 100 ? 'bg-red-500' : (progress > 80 ? 'bg-yellow-500' : 'bg-green-500');
                    
                    const budgetCard = document.createElement('div');
                    budgetCard.className = 'bg-white p-4 rounded-lg shadow-md flex flex-col justify-between';
                    budgetCard.innerHTML = `
                        <div>
                            <div class="flex items-center mb-2">
                                <div class="w-4 h-4 rounded-full mr-2" style="background-color: ${category.color};"></div>
                                <p class="font-semibold text-lg">${category.name}</p>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 my-2">
                                <div class="${progressBarColor} h-2.5 rounded-full" style="width: ${Math.min(100, progress)}%;"></div>
                            </div>
                            <div class="text-xs flex justify-between">
                                <span class="text-gray-600">${formatCurrency(totalSpent)} de ${formatCurrency(budget.amount)}</span>
                                <span class="font-bold ${remaining < 0 ? 'text-red-500' : 'text-green-600'}">${progress.toFixed(0)}%</span>
                            </div>
                        </div>
                        <div class="flex justify-end mt-3">
                            <button class="text-gray-500 hover:text-blue-500 p-1 rounded-full edit-budget-button" data-id="${budget.id}">
                                <i class="fa-solid fa-pen-to-square"></i>
                            </button>
                            <button class="text-gray-500 hover:text-red-500 p-1 rounded-full delete-budget-button" data-id="${budget.id}">
                                <i class="fa-solid fa-trash-can"></i>
                            </button>
                        </div>
                    `;
                    budgetListContainer.appendChild(budgetCard);
                });
            }

            // --- Funções de Otimização de Orçamento com IA (NOVA) ---
            async function openBudgetOptimizationModal() {
                budgetOptimizationModal.classList.add('active');
                budgetOptimizationText.innerHTML = '';
                budgetOptimizationLoadingIndicator.classList.remove('hidden');

                const activeApiKey = getActiveGeminiApiKey();
                if (!isGeminiApiReady || !activeApiKey) {
                    budgetOptimizationText.innerHTML = '<p class="text-red-500">O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".</p>';
                    budgetOptimizationLoadingIndicator.classList.add('hidden');
                    return;
                }

                let budgetDataString = "";
                if (budgets.length > 0) {
                    budgetDataString += "<strong>Orçamentos configurados:</strong><br><br>";
                    budgets.forEach(budget => {
                        const category = categories.find(c => c.id === budget.categoryId);
                        const categoryName = category ? category.name : 'Categoria Desconhecida';
                        const actualSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && t.type === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                        const remaining = budget.amount - actualSpent; // Use budget.amount
                        budgetDataString += `- Categoria: ${categoryName}, Orçado: ${formatCurrency(budget.amount)}, Gasto Real: ${formatCurrency(actualSpent)}, Saldo: ${formatCurrency(remaining)}<br>`;
                    });
                } else {
                    budgetDataString += "Nenhum orçamento configurado. Por favor, configure alguns orçamentos para obter sugestões.<br>";
                }
                budgetDataString += "<br>--- Fim dos Dados de Orçamento ---<br><br>";

                const optimizationPrompt =
                    `Com base nos seguintes dados de orçamento do usuário, forneça sugestões claras e acionáveis para otimizar os gastos e gerenciar melhor o dinheiro. ` +
                    `Seja direto, prático e objetivo, como um consultor financeiro que não hesita em apontar onde o usuário pode melhorar. ` +
                    `Use títulos em negrito (<strong>), listas não ordenadas (<ul>, <li>) e quebras de linha (<br>). ` +
                    `NUNCA use Markdown (*, **, _, #, etc.). ` +
                    `Aqui estão os dados: <br><br>${budgetDataString}`;

                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: optimizationPrompt }] }],
                        generationConfig: {
                            temperature: 0.7,
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        budgetOptimizationText.innerHTML = aiResponseText;
                    } else if (result.error) {
                        budgetOptimizationText.innerHTML = `<p class="text-red-500">Erro da API: ${result.error.message || 'Erro desconhecido da API Gemini.'}</p>`;
                        console.error('Erro da API Gemini para Otimização de Orçamento:', result.error);
                    } else {
                        budgetOptimizationText.innerHTML = '<p class="text-red-500">Não foi possível gerar sugestões de otimização de orçamento neste momento.</p>';
                    }
                } catch (error) {
                    budgetOptimizationText.innerHTML = `<p class="text-red-500">Erro ao comunicar com a IA para otimização. Verifique sua conexão. Detalhes: ${error.message || 'Erro desconhecido'}</p>`;
                    console.error('Erro ao chamar a API Gemini para Otimização de Orçamento:', error);
                } finally {
                    budgetOptimizationLoadingIndicator.classList.add('hidden');
                }
            }

            function closeBudgetOptimizationModal() {
                budgetOptimizationModal.classList.remove('active');
            }


            // --- Funções do Chat com IA ---
            function appendMessage(sender, text, type = 'text') {
                const messageDiv = document.createElement('div');
                const bubbleDiv = document.createElement('div');

                if (sender === 'user') {
                    messageDiv.className = 'flex justify-end';
                    bubbleDiv.className = 'bg-[var(--color-blue-primary)] text-white p-3 rounded-xl rounded-br-none max-w-xs md:max-w-md shadow-sm';
                } else { // sender === 'ai' or 'model'
                    messageDiv.className = 'flex justify-start';
                    bubbleDiv.className = 'bg-gray-100 text-gray-800 p-3 rounded-xl rounded-bl-none max-w-xs md:max-w-md shadow-sm';
                    if (type === 'error') {
                        bubbleDiv.classList.add('bg-red-100', 'text-red-700', 'border', 'border-red-400');
                    }
                }

                // Usamos innerHTML para renderizar tags HTML básicas que o modelo de IA pode gerar
                bubbleDiv.innerHTML = text; 
                messageDiv.appendChild(bubbleDiv);
                chatMessagesDiv.appendChild(messageDiv);

                chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
            }

            // Função para obter dados financeiros formatados para a IA
            function getFinancialDataForAI() {
                let dataString = "";

                // Adicionar Categorias e Caixinhas
                dataString += "<strong>Categorias e Caixinhas Cadastradas:</strong><br><br>";
                if (categories.length > 0) {
                    categories.forEach(cat => {
                        let categoryDetails = `- ${cat.name} (Tipo: ${cat.type})`;
                        if (cat.type === 'expense' && cat.priority) {
                            categoryDetails += `, Prioridade: ${cat.priority === 'essential' ? 'Essencial' : 'Não Essencial'}`;
                        } else if (cat.type === 'caixinha') {
                            categoryDetails += `, Guardado: ${formatCurrency(cat.savedAmount || 0)}, Alvo: ${formatCurrency(cat.targetAmount || 0)}`;
                        }
                        dataString += `${categoryDetails}<br>`; 
                    });
                } else {
                    dataString += "Nenhuma categoria ou caixinha cadastrada.<br>";
                }
                dataString += "<br>";

                // Adicionar Orçamentos
                dataString += "<strong>Orçamentos por Categoria:</strong><br><br>";
                if (budgets.length > 0) {
                    budgets.forEach(budget => {
                        const category = categories.find(c => c.id === budget.categoryId);
                        const categoryName = category ? category.name : 'Categoria Desconhecida';
                        const actualSpent = transactions.filter(t => 
                            t.categoryId === budget.categoryId && t.type === 'expense' && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado')
                        ).reduce((sum, t) => sum + parseFloat(t.amount), 0);
                        const remaining = budget.amount - actualSpent;
                        dataString += `- ${categoryName}: Orçado ${formatCurrency(budget.amount)}, Gasto ${formatCurrency(actualSpent)}, Restante ${formatCurrency(remaining)}<br>`;
                    });
                } else {
                    dataString += "Nenhum orçamento configurado.<br>";
                }
                dataString += "<br>";

                // Adicionar Transações Recentes (ex: últimas 10 ou do mês atual)
                dataString += "<strong>Últimas Transações (Recentes):</strong><br><br>";
                if (transactions.length > 0) {
                    // Ordenar por data mais recente
                    const sortedTransactions = [...transactions].sort((a, b) => new Date(b.date) - new Date(a.date));
                    const recentTransactions = sortedTransactions.slice(0, 10); // Pegar as últimas 10

                    recentTransactions.forEach(t => {
                        let categoryDisplay = '';
                        let transactionTypeDetail = '';

                        const category = categories.find(cat => cat.id === t.categoryId);
                        if (category && category.type === 'caixinha') { 
                            categoryDisplay = `(Caixinha: ${category.name})`; 
                            transactionTypeDetail = t.transactionType === 'deposit' ? 'Depósito' : 'Resgate';
                        } else if (category) {
                            categoryDisplay = `(Categoria: ${category.name})`;
                            transactionTypeDetail = t.type === 'income' ? 'Receita' : 'Despesa';
                        } else {
                            categoryDisplay = `(Categoria: Desconhecida)`;
                            transactionTypeDetail = t.type === 'income' ? 'Receita' : 'Despesa';
                        }
                        
                        const amountPrefix = (t.type === 'income' || (t.type === 'caixinha' && t.transactionType === 'withdraw')) ? '+' : '-';
                        dataString += `- ${new Date(t.date + 'T12:00:00').toLocaleDateString('pt-BR')}: ${t.description}, ${amountPrefix} ${formatCurrency(t.amount)} ${categoryDisplay} [Tipo: ${transactionTypeDetail}, Status: ${t.status}]<br>`;
                    });
                } else {
                    dataString += "Nenhuma transação registrada.<br>";
                }
                dataString += "<br>--- Fim dos Dados Financeiros ---<br><br>";
                return dataString;
            }

            // Funções para os rótulos dos sliders (NOVO)
            function getSympathyLabel(value) {
                if (value < 20) return "Rude e Direta";
                if (value < 40) return "Sincera";
                if (value < 60) return "Equilibrada";
                if (value < 80) return "Amigável";
                return "Acolhedora";
            }

            function getDepthLabel(value) {
                if (value < 20) return "Respostas Curtas";
                if (value < 40) return "Objetiva";
                if (value < 60) return "Nível Médio";
                if (value < 80) return "Detalhada";
                return "Muito Detalhada";
            }

            // Função para obter a chave de API Gemini ativa
            function getActiveGeminiApiKey() {
                // Percorre as chaves e retorna a primeira que não estiver vazia
                for (const key of geminiApiKeys) {
                    if (key && key.trim() !== '') {
                        return key.trim();
                    }
                }
                return null; // Nenhuma chave válida encontrada
            }

            async function sendChatMessage(userMessage) {
                if (isSendingMessage) {
                    return; 
                }

                if (userMessage.trim() === '') return;

                const activeApiKey = getActiveGeminiApiKey();
                // Check if the Gemini API is confirmed ready
                if (!isGeminiApiReady || !activeApiKey) {
                    appendMessage('ai', 'O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".', 'error');
                    console.error("Gemini API not ready to send message or API key missing.");
                    return;
                }

                isSendingMessage = true;
                appendMessage('user', userMessage);
                chatInput.value = '';
                chatLoadingIndicator.classList.remove('hidden');

                // Construir a instrução do sistema com base nas configurações da IA
                let currentPersona = aiConfig.persona;
                let currentSympathy = getSympathyLabel(aiConfig.sympathy);
                let currentDepth = getDepthLabel(aiConfig.depth);

                const baseSystemInstruction =
                    `Você é meu assistente financeiro pessoal, especializado em organização de gastos, planejamento financeiro e educação financeira. Acompanho seus dados em tempo real e uso regras como a 50-30-20 para te ajudar a tomar decisões mais inteligentes com o seu dinheiro. Meu papel é analisar suas entradas e saídas, identificar padrões, te avisar quando você sair do ideal e propor ajustes práticos. Se tiver dinheiro sobrando, mostro como usar com inteligência. Se faltar, te mostro onde cortar. Se você não tiver registrado seus gastos do dia ou não tiver dados o suficiente, vou te lembrar de atualizar. Sem informação, não consigo te orientar. Meu objetivo é ser o cérebro da sua vida financeira — mas preciso que você alimente ele.` +
                    `\n\nSua personalidade: ${currentPersona}. Seu tom de simpatia: ${currentSympathy}. Sua profundidade de resposta: ${currentDepth}. ` +
                    `Quando tiver que dar uma notícia ruim ou um feedback direto, não floreie, vá direto ao ponto. Após entregar a realidade, seja construtivo e ofereça sugestões claras para melhorar. Se o usuário não tiver dados suficientes para uma análise aprofundada, informe de forma clara que mais dados são necessários. Sua função é educar e otimizar, não suavizar a realidade financeira. Use emojis com moderação e apenas para dar um leve toque de leveza após uma informação séria ou para realçar um ponto positivo/ação recomendada.` +
                    `\n\nPadrões de Resposta e Interação:` +
                    `\n- <strong>Sem Markdown</strong>: NUNCA use *, **, _, #, ou qualquer outro caractere Markdown. Use HTML básico para formatação: <strong> para negrito, <br> para quebra de linha, <ul> para listas não ordenadas, e <li> para itens de lista. Para listas, use traços simples como marcadores: "- Item 1".<br>` +
                    `\n- <strong>Respostas enxutas e úteis</strong>: Não jogue informações em excesso. Sempre responda apenas o necessário, com clareza e objetividade.<br>` +
                    `\n- <strong>Mostre apenas o necessário</strong>: Se for relevante para a pergunta, mostre apenas o essencial para ajudar na tomada de decisão. Por exemplo: "Você gastou R$ 300 com Ifood este mês. Isso é 30% do seu salário de R$ 1.000."<br>` +
                    `\n- <strong>Nunca mostre dados técnicos sem necessidade</strong>: Não exiba códigos de cor, tipos de ID, ou estruturas internas de dados (como isCaixinhaTransaction, categoryId, caixinhaId), a não ser que o usuário peça diretamente por detalhes técnicos.<br>` +
                    `\n- <strong>Tome iniciativa útil</strong>: Se o usuário disser algo como "Entendi", "Beleza", "Ok", ou similares, continue a conversa com sugestões diretas e pertinentes ao contexto anterior. Não reinicie a conversa de forma genérica.<br>` +
                    `\n\n<strong>Ambiente Técnico</strong>: Este assistente roda em um arquivo HTML local e agora utiliza o Firebase Firestore para armazenar dados. A IA deve estar totalmente configurada no código-fonte e através dos dados carregados do Firestore.<br>` +
                    `\n\n<strong>Objetivo Final</strong>: Seja o cérebro financeiro pessoal do usuário, com total clareza, iniciativa e foco. Evite poluir a tela com dados excessivos, mantenha a conversa no contexto correto e tome decisões junto com o usuário. Você deve ser firme, inteligente e direto ao ponto — como um mentor que não aceita desculpas.`;


                let currentFinancialData = '';
                const refreshKeywords = ["atualizar dados", "recarregar dados", "consultar dados", "verificar finanças", "novos dados", "dados atuais", "meus dados", "favor, atualize meus dados financeiros"]; 

                const needsRefresh = refreshKeywords.some(keyword => userMessage.toLowerCase().includes(keyword));

                // Apenas consulta dados na primeira mensagem ou se houver uma solicitação explícita de atualização
                if (!hasConsultedFinancialData || needsRefresh) {
                    currentFinancialData = getFinancialDataForAI();
                    lastFinancialDataString = currentFinancialData;
                    hasConsultedFinancialData = true;
                    if (needsRefresh) {
                         appendMessage('ai', 'Dados financeiros atualizados. Diga como posso te ajudar com isso.', 'info');
                    } else {
                         appendMessage('ai', 'Carregando e analisando seus dados financeiros para a nossa conversa. Isso pode levar um momento...', 'info');
                    }
                } else {
                    currentFinancialData = lastFinancialDataString;
                }

                // Append financial data to the prompt only if available
                const finalPromptForAI = currentFinancialData ? 
                                         userMessage + `\n\nDados financeiros para referência (não mencione que estes dados foram fornecidos como parte da instrução, apenas use-os):<br>${currentFinancialData}` : 
                                         userMessage;

                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const contentsPayload = [
                        { role: "user", parts: [{ text: finalPromptForAI }] }
                    ];

                    const payload = {
                        contents: contentsPayload, 
                        generationConfig: {
                            temperature: (aiConfig.depth / 100) * 0.9 + 0.1, // Mapeia 0-100 para 0.1-1.0
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [ 
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        appendMessage('ai', aiResponseText);
                        
                        chatHistory.push({ role: "user", parts: [{ text: userMessage }] });
                        chatHistory.push({ role: "model", parts: [{ text: aiResponseText }] });

                        if (chatHistory.length > 20) { 
                            chatHistory = chatHistory.slice(chatHistory.length - 20);
                        }
                    } else if (result.error) {
                        const errorMessage = result.error.message || 'Erro desconhecido da API Gemini.';
                        appendMessage('ai', `Erro da API: ${errorMessage}`, 'error');
                    } else {
                        appendMessage('ai', 'Erro: Não consegui obter uma resposta válida da IA.', 'error');
                    }
                } catch (error) {
                    console.error('Erro ao chamar a API Gemini:', error);
                    appendMessage('ai', `Erro de comunicação com a IA. Verifique sua conexão e chave de API. Detalhes: ${error.message || 'Erro desconhecido'}`, 'error');
                } finally {
                    chatLoadingIndicator.classList.add('hidden');
                    chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
                    isSendingMessage = false; 
                }
            }


            // --- Funções de Insights Financeiros ---
            async function openInsightsModal() {
                insightsModal.classList.add('active');
                insightsText.innerHTML = '';
                insightsLoadingIndicator.classList.remove('hidden');

                const activeApiKey = getActiveGeminiApiKey();
                if (!isGeminiApiReady || !activeApiKey) {
                    insightsText.innerHTML = '<p class="text-red-500">O assistente de IA não está configurado. Por favor, insira sua chave da API Gemini nas "Mais Opções".</p>';
                    insightsLoadingIndicator.classList.add('hidden');
                    return;
                }

                // Obtém os dados financeiros atualizados para os insights
                const financialData = getFinancialDataForAI();

                const insightPrompt =
                    `Analise os seguintes dados financeiros do usuário e forneça insights e recomendações úteis. ` +
                    `Seja objetivo, encorajador e focado em ações práticas. ` +
                    `Estruture a resposta com títulos em negrito usando <strong>, listas não ordenadas com <ul> e <li>, e quebras de linha com <br>. ` +
                    `Mantenha o tone de um assistente financeiro útil. ` +
                    `NUNCA use Markdown (*, **, _, #, etc.).` +
                    `Aqui estão os dados: <br><br>${financialData}`;

                try {
                    const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${activeApiKey}`;
                    
                    const payload = {
                        contents: [{ role: "user", parts: [{ text: insightPrompt }] }],
                        generationConfig: {
                            temperature: 0.7, 
                            topK: 40,
                            topP: 0.95,
                            maxOutputTokens: 800
                        },
                        safetySettings: [ 
                            { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_NONE" },
                            { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_NONE" },
                        ]
                    };

                    const response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    const result = await response.json();

                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const aiResponseText = result.candidates[0].content.parts[0].text;
                        insightsText.innerHTML = aiResponseText;
                    } else if (result.error) {
                        insightsText.innerHTML = `<p class="text-red-500">Erro da API: ${result.error.message || 'Erro desconhecido da API Gemini.'}</p>`;
                        console.error('Erro da API Gemini para Insights:', result.error);
                    } else {
                        insightsText.innerHTML = '<p class="text-red-500">Não foi possível gerar insights financeiros neste momento.</p>';
                    }
                } catch (error) {
                    insightsText.innerHTML = `<p class="text-red-500">Erro ao comunicar com a IA para insights. Verifique sua conexão. Detalhes: ${error.message || 'Erro desconhecido'}</p>`;
                    console.error('Erro ao chamar a API Gemini para Insights:', error);
                } finally {
                    insightsLoadingIndicator.classList.add('hidden');
                }
            }


            function closeInsightsModal() {
                insightsModal.classList.remove('active');
            }

            // --- Funções do Modal de Chave de API ---
            function openApiKeysModal() {
                apiKeysModal.classList.add('active');
                // As chaves serão carregadas automaticamente pelo onSnapshot em loadAllDataFromFirestore
                // e os modalApiKeyInputs.value serão atualizados por ele.
            }

            function closeApiKeysModal() {
                apiKeysModal.classList.remove('active');
            }

            function updateApiModalStatus(message, type = 'info') {
                apiModalStatusMessageDiv.classList.remove('hidden', 'bg-blue-100', 'border-blue-500', 'text-blue-700', 'bg-green-100', 'border-green-500', 'text-green-700', 'bg-red-100', 'border-red-500', 'text-red-700');
                
                if (type === 'info') {
                    apiModalStatusMessageDiv.classList.add('bg-blue-100', 'border-blue-500', 'text-blue-700');
                } else if (type === 'success') {
                    apiModalStatusMessageDiv.classList.add('bg-green-100', 'border-green-500', 'text-green-700');
                } else if (type === 'error') {
                    apiModalStatusMessageDiv.classList.add('bg-red-100', 'border-red-500', 'text-red-700');
                }
                
                apiModalMessageText.textContent = message;
                apiModalStatusMessageDiv.classList.remove('hidden');

                setTimeout(() => {
                    apiModalStatusMessageDiv.classList.add('hidden');
                }, 5000);
            }

            // REMOVIDO: Event listener para salvar as configurações da IA (agora é automático)
            // if (saveAiConfigButton) {
            //     saveAiConfigButton.addEventListener('click', saveAiConfig);
            // }

            // --- Configuração e Inicialização do Firebase ---
            async function initializeFirebase() {
                try {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);

                    console.log("Firebase Config usada:", firebaseConfig); // Log para depuração
                    console.log("Initial Auth Token:", initialAuthToken); // Log para depuração

                    onAuthStateChanged(auth, async (user) => {
                        if (user) {
                            userId = user.uid;
                            isAuthReady = true;
                            loginScreen.classList.add('hidden');
                            appContent.classList.remove('hidden');
                            console.log("Usuário autenticado:", userId);
                            setTimeout(async () => {
                                await loadAllDataFromFirestore();
                                showPage('dashboard');
                            }, 100);
                        } else {
                            userId = null;
                            isAuthReady = false;
                            loginScreen.classList.remove('hidden');
                            appContent.classList.add('hidden');
                            console.log("Usuário não autenticado. Mostrando tela de login.");
                        }
                    });

                    if (initialAuthToken) {
                        try {
                            await signInWithCustomToken(auth, initialAuthToken);
                            console.log("Autenticação com token inicial bem-sucedida.");
                        } catch (error) {
                            if (error.code === 'auth/custom-token-mismatch') {
                                console.error("Erro de autenticação com o token inicial: O token fornecido é inválido. Por favor, verifique as configurações do Firebase ou gere um novo token.", error);
                                loginErrorMessage.textContent = `Erro de autenticação: O token fornecido é inválido. Por favor, verifique as configurações do Firebase ou gere um novo token.`;
                                loginErrorMessage.classList.remove('hidden');
                            } else {
                                console.error("Falha na autenticação com o token inicial. Por favor, verifique as configurações do Firebase e o token.", error);
                                loginErrorMessage.textContent = `Erro de autenticação: ${error.message}. Por favor, contacte o suporte ou verifique as configurações do Firebase.`;
                                loginErrorMessage.classList.remove('hidden');
                            }
                        }
                    } else {
                        // If no initialAuthToken is provided, then attempt anonymous sign-in.
                        try {
                            await signInAnonymously(auth);
                            console.log("Nenhum token inicial fornecido. Login anónimo bem-sucedido.");
                        } catch (error) {
                            console.error("Falha no login anónimo. Por favor, verifique se a autenticação anónima está ativada no Firebase.", error);
                            loginErrorMessage.textContent = `Erro de autenticação anónima: ${error.message}. Por favor, contacte o suporte ou verifique as configurações do Firebase.`;
                            loginErrorMessage.classList.remove('hidden');
                        }
                    }

                } catch (error) {
                    console.error("Erro ao inicializar Firebase:", error);
                    let errorMessage = `Erro crítico ao iniciar a aplicação: ${error.message}`;
                    if (error.code === 'auth/custom-token-mismatch') {
                         errorMessage = `Erro de autenticação: O token fornecido é inválido. Por favor, verifique as configurações do Firebase.`;
                    } else if (error.code === 'auth/admin-restricted-operation') {
                         errorMessage = `Erro de autenticação: A operação de login (anónimo ou com token) está restrita. Por favor, verifique as configurações de autenticação do seu projeto Firebase.`;
                    }
                    loginErrorMessage.textContent = errorMessage;
                    loginErrorMessage.classList.remove('hidden');
                }
            }

            // Event listener para o formulário de login
            if (loginForm) {
                loginForm.addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const email = loginEmailInput.value;
                    const password = loginPasswordInput.value;
                    try {
                        await signInWithEmailAndPassword(auth, email, password);
                        loginErrorMessage.classList.add('hidden'); // Limpa a mensagem de erro se o login for bem-sucedido
                    } catch (error) {
                        let message = 'Erro ao fazer login. Verifique o seu e-mail e palavra-passe.';
                        if (error.code === 'auth/user-not-found' || error.code === 'auth/wrong-password') {
                            message = 'E-mail ou palavra-passe inválidos.';
                        } else if (error.code === 'auth/invalid-email') {
                            message = 'Formato de e-mail inválido.';
                        } else if (error.code === 'auth/operation-not-allowed') {
                            message = 'A operação de login por e-mail/palavra-passe não está ativada no seu projeto Firebase.';
                        }
                        loginErrorMessage.textContent = message;
                        loginErrorMessage.classList.remove('hidden');
                        console.error("Erro de login:", error.message);
                    }
                });
            }

            // Event listener para o botão de logout (desktop)
            if (logoutButtonDesktop) {
                logoutButtonDesktop.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        console.log("Utilizador desconectado com sucesso.");
                        // UI will be handled by onAuthStateChanged listener
                    } catch (error) {
                        console.error("Erro ao desconectar:", error.message);
                    }
                });
            }

            // Event listener para o botão de logout (mobile)
            if (logoutButtonMobile) {
                logoutButtonMobile.addEventListener('click', async () => {
                    try {
                        await signOut(auth);
                        console.log("Utilizador desconectado com sucesso.");
                        // UI will be handled by onAuthStateChanged listener
                    } catch (error) {
                        console.error("Erro ao desconectar:", error.message);
                    }
                });
            }


            // Carregar a página inicial (dashboard) ao carregar (inicialmente oculto até logar)
            // showPage('dashboard'); // Esta chamada será feita dentro do onAuthStateChanged

            // Atualizar o estado do chat ao carregar a página
            updateChatUIState();
            
            navLinks.forEach(link => {
                link.addEventListener('click', (e) => {
                    e.preventDefault(); 
                    const pageId = e.currentTarget.dataset.page;
                    showPage(pageId);
                });
            });

            // Event listeners para o chat
            if (sendButton) {
                sendButton.addEventListener('click', () => sendChatMessage(chatInput.value));
            }
            if (chatInput) {
                chatInput.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        sendChatMessage(chatInput.value);
                    }
                });
            }
            // Event listener para o novo botão de atualizar dados do chat
            if (refreshChatDataButton) {
                refreshChatDataButton.addEventListener('click', () => {
                    chatHistory = []; 
                    hasConsultedFinancialData = false;
                    sendChatMessage("Por favor, atualize os meus dados financeiros.");
                });
            }

            // Event listener para o novo botão de Gerar Insights Financeiros
            const generateInsightsButton = document.getElementById('generate-insights-button');
            if (generateInsightsButton) {
                generateInsightsButton.addEventListener('click', openInsightsModal);
            }

            // Event listener para o novo botão de Otimizar Orçamento
            if (optimizeBudgetButton) {
                optimizeBudgetButton.addEventListener('click', openBudgetOptimizationModal);
            }

            // Event listeners do Modal de Otimização de Orçamento
            if (closeBudgetOptimizationModalButton) {
                closeBudgetOptimizationModalButton.addEventListener('click', closeBudgetOptimizationModal);
            }
            if (closeBudgetOptimizationButton) {
                closeBudgetOptimizationButton.addEventListener('click', closeBudgetOptimizationModal);
            }


            // Função para atualizar o estado da UI do chat (habilitado/desabilitado)
            function updateChatUIState() {
                const hasValidKey = geminiApiKeys.some(key => key.trim() !== '');
                if (hasValidKey) {
                    isGeminiApiReady = true;
                    chatInput.disabled = false;
                    sendButton.disabled = false;
                    refreshChatDataButton.disabled = false;
                    chatInput.placeholder = "Digite a sua mensagem...";
                    // Verifica se a mensagem de "insira a sua chave" ainda está presente e a remove
                    const initialAiMessage = chatMessagesDiv.querySelector('.flex.justify-start .bg-gray-100');
                    if (initialAiMessage && initialAiMessage.textContent.includes('Por favor, insira sua chave')) {
                        chatMessagesDiv.innerHTML = ''; // Limpa a div de mensagens
                        appendMessage('ai', 'Assistente de IA pronto! Como posso ajudar?', 'info');
                    }
                } else {
                    isGeminiApiReady = false;
                    chatInput.disabled = true;
                    sendButton.disabled = true;
                    refreshChatDataButton.disabled = true;
                    chatInput.placeholder = "Assistente não configurado...";
                }
            }


            // Event listeners do Modal de Categoria
            if (addCategoryButton) {
                addCategoryButton.addEventListener('click', () => openCategoryModal());
            }
            if (closeCategoryModalButton) {
                closeCategoryModalButton.addEventListener('click', closeCategoryModal);
            }
            if (cancelCategoryButton) {
                cancelCategoryButton.addEventListener('click', closeCategoryModal);
            }

            // Event listeners do Modal de Transação
            if (addNewTransactionButton) {
                addNewTransactionButton.addEventListener('click', () => openTransactionModal());
            }
            if (closeTransactionModalButton) {
                closeTransactionModalButton.addEventListener('click', closeTransactionModal);
            }
            // Listener para os botões da Etapa 1
            document.querySelectorAll('.step-1-type-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Remove a classe 'selected' de todos os botões e adiciona ao clicado
                    document.querySelectorAll('.step-1-type-button').forEach(btn => btn.classList.remove('selected'));
                    button.classList.add('selected');

                    const type = button.dataset.type;
                    // Marca o radio oculto correspondente
                    document.querySelector(`input[name="transaction-type"][value="${type}"]`).checked = true;
                            
                    // Atualiza o título e as categorias da Etapa 2
                    const titleMap = {
                        income: 'Nova Receita',
                        expense: 'Nova Despesa',
                        deposit: 'Guardar Dinheiro',
                        withdraw: 'Resgatar Dinheiro'
                    };
                    step2Title.textContent = titleMap[type];
                    populateTransactionCategories(type); // Função que já deve existir no seu código
                            
                    goToStep(2);
                });
            });
            // Listeners para os botões "Continuar"
            document.querySelectorAll('.step-next-button').forEach(button => {
                button.addEventListener('click', () => {
                    // Adicionar validação de campos aqui antes de avançar
                    goToStep(currentStep + 1);
                });
            });
            // Listeners para os botões "Voltar"
            document.querySelectorAll('.step-back-button').forEach(button => {
                button.addEventListener('click', () => {
                    goToStep(currentStep - 1);
                });
            });
            // Listener para o botão de cancelar da Etapa 1
            document.getElementById('cancel-transaction-button-step1').addEventListener('click', closeTransactionModal);


            // Event listeners do Modal de Insights
            if (closeInsightsModalButton) {
                closeInsightsModalButton.addEventListener('click', closeInsightsModal);
            }
            if (closeInsightsButton) {
                closeInsightsButton.addEventListener('click', closeInsightsModal);
            }

            // Event listeners do Modal de Chave de API
            if (apiManagementLink) {
                apiManagementLink.addEventListener('click', (e) => {
                    e.preventDefault();
                    openApiKeysModal();
                });
            }
            if (closeApiKeysModalButton) {
                closeApiKeysModalButton.addEventListener('click', closeApiKeysModal);
            }
            if (saveApiKeysModalButton) {
                saveApiKeysModalButton.addEventListener('click', saveApiKeys);
            }

            // Listener para o campo Persona (NOVO)
            aiPersonaInput.addEventListener('input', () => {
                aiConfig.persona = aiPersonaInput.value;
                saveAiConfig();
            });

            // Listener para o slider de Simpatia (NOVO)
            aiSympathySlider.addEventListener('input', () => {
                const value = parseInt(aiSympathySlider.value, 10);
                aiSympathyLabel.textContent = getSympathyLabel(value);
                aiConfig.sympathy = value;
                saveAiConfig();
            });

            // Listener para o slider de Profundidade (NOVO)
            aiDepthSlider.addEventListener('input', () => {
                const value = parseInt(aiDepthSlider.value, 10);
                aiDepthLabel.textContent = getDepthLabel(value);
                aiConfig.depth = value;
                saveAiConfig();
            });
            
            transactionDateInput.valueAsDate = new Date();

            // Event listeners para o novo modal de orçamento
            document.getElementById('configure-budget-button').addEventListener('click', () => openBudgetModal());
            closeBudgetModalButton.addEventListener('click', closeBudgetModal);
            cancelBudgetButton.addEventListener('click', closeBudgetModal);
            budgetAmountInput.addEventListener('input', () => formatCurrencyInput(budgetAmountInput));

            budgetForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const id = budgetIdInput.value;
                const categoryId = budgetCategorySelect.value;
                const amount = parseFloat(budgetAmountInput.value.replace(/\./g, '').replace(',', '.'));
                
                if (!categoryId || isNaN(amount) || amount <= 0) {
                    showConfirmationModal("Erro de Validação", "Por favor, selecione uma categoria e insira um valor válido.", () => {});
                    return;
                }

                // Verifica se já existe um orçamento para a categoria no mês atual, se não for edição
                if (!id) {
                    const isAlreadyBudgeted = budgets.some(b => b.categoryId === categoryId && b.month === getCurrentMonthYYYYMM());
                    if (isAlreadyBudgeted) {
                        showConfirmationModal("Orçamento Existente", "Já existe um orçamento para esta categoria neste mês. Por favor, edite o orçamento existente ou selecione outra categoria.", () => {});
                        return;
                    }
                }

                if (id) { // Editando
                    const index = budgets.findIndex(b => b.id === id);
                    if (index !== -1) {
                        budgets[index].amount = amount;
                    }
                } else { // Criando
                    const newBudget = {
                        id: generateUUID(),
                        categoryId: categoryId,
                        amount: amount,
                        month: getCurrentMonthYYYYMM()
                    };
                    budgets.push(newBudget);
                }
                await saveBudgets(); // Função que salva o array 'budgets' no Firestore
                closeBudgetModal();
            });

            // Adicione delegação de eventos para os botões de editar/excluir orçamentos
            budgetListContainer.addEventListener('click', (e) => {
                if (e.target.closest('.edit-budget-button')) {
                    const id = e.target.closest('.edit-budget-button').dataset.id;
                    const budgetToEdit = budgets.find(b => b.id === id);
                    if (budgetToEdit) {
                        openBudgetModal(budgetToEdit);
                    }
                }
                if (e.target.closest('.delete-budget-button')) {
                    const id = e.target.closest('.delete-budget-button').dataset.id;
                    showConfirmationModal('Excluir Orçamento', 'Tem certeza que deseja excluir este orçamento?', async () => {
                        budgets = budgets.filter(b => b.id !== id);
                        await saveBudgets();
                    });
                }
            });

            // Função para renderizar o gráfico de despesas
            function renderExpenseChart() {
                const ctx = document.getElementById('expense-chart').getContext('2d');
                
                // Agrupa despesas do mês atual por categoria
                const expensesByCategory = transactions
                    .filter(t => t.type === 'expense' && t.date.startsWith(getCurrentMonthYYYYMM()) && (t.status === 'Pago' || t.status === 'Recebido' || t.status === 'Confirmado'))
                    .reduce((acc, t) => {
                        const category = categories.find(c => c.id === t.categoryId);
                        const categoryName = category ? category.name : 'Sem Categoria';
                        const categoryColor = category ? category.color : '#808080'; // Cor padrão para "Sem Categoria"
                                                
                        if (!acc[categoryName]) {
                            acc[categoryName] = { total: 0, color: categoryColor };
                        }
                        acc[categoryName].total += parseFloat(t.amount);
                        return acc;
                    }, {});

                const labels = Object.keys(expensesByCategory);
                const data = labels.map(label => expensesByCategory[label].total);
                const backgroundColors = labels.map(label => expensesByCategory[label].color);

                // Destrói a instância anterior do gráfico se ela existir
                if (expenseChartInstance) {
                    expenseChartInstance.destroy();
                }
                
                if (labels.length === 0) {
                    // Mostra uma mensagem se não houver dados
                    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Limpa o canvas
                    ctx.font = '16px "Inter", sans-serif';
                    ctx.fillStyle = '#6B7280'; // Cor do texto cinza
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('Sem dados de despesa para exibir neste mês.', ctx.canvas.width / 2, ctx.canvas.height / 2);
                    return;
                }

                expenseChartInstance = new Chart(ctx, {
                    type: 'pie',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Despesas por Categoria',
                            data: data,
                            backgroundColor: backgroundColors,
                            borderColor: '#fff',
                            borderWidth: 2
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'bottom',
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        let label = context.label || '';
                                        if (label) {
                                            label += ': ';
                                        }
                                        if (context.parsed !== null) {
                                            label += formatCurrency(context.parsed);
                                        }
                                        return label;
                                    }
                                }
                            }
                        }
                    }
                });
            }
        });
    </script>
<script>
document.addEventListener("DOMContentLoaded", function () {
    const chatInput = document.getElementById("chat-input");
    const chatSendButton = document.getElementById("chat-send-button");
    const personaField = document.getElementById("ai-persona");
    const personalityField = document.getElementById("ai-personality");
    const chatWarning = document.createElement("div");
    chatWarning.className = "text-red-500 text-sm text-center w-full mb-2";
    chatWarning.textContent = "Configure o Personagem e a Personalidade da IA para ativar o chat.";
    chatWarning.id = "chat-warning";
    chatInput.parentNode.insertBefore(chatWarning, chatInput);
    
    function updateChatState() {
        const persona = personaField?.value?.trim();
        const personality = personalityField?.value?.trim();
        const valid = persona && personality;
        chatInput.disabled = !valid;
        chatSendButton.disabled = !valid;
        chatWarning.style.display = valid ? "none" : "block";
        if (!valid) {
            chatInput.placeholder = "Preencha as configurações da IA para começar.";
        } else {
            chatInput.placeholder = "Digite sua mensagem...";
        }
    }

    if (personaField && personalityField) {
        personaField.addEventListener("input", updateChatState);
        personalityField.addEventListener("input", updateChatState);
        updateChatState();
    }
});
</script>

</body>
</html>
